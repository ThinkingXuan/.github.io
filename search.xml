<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[蓝桥杯试题——Sine之舞]]></title>
    <url>%2F2019%2F02%2F18%2Flanqiao%2FSine%E4%B9%8B%E8%88%9E%2F</url>
    <content type="text"><![CDATA[Sine之舞问题描述最近FJ为他的奶牛们开设了数学分析课，FJ知道若要学好这门课，必须有一个好的三角函数基本功。所以他准备和奶牛们做一个“Sine之舞”的游戏，寓教于乐，提高奶牛们的计算能力。不妨设: &emsp;&emsp;$An=sin(1–sin(2+sin(3–sin(4+…sin(n))…)$ &emsp;&emsp;$Sn=(…(A1+n)A2+n-1)A3+…+2)An+1$ FJ想让奶牛们计算Sn的值，请你帮助FJ打印出Sn的完整表达式，以方便奶牛们做题。 输入格式仅有一个数：N&lt;201。 输出格式请输出相应的表达式Sn，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入3 样例输出$((sin(1)+3)sin(1–sin(2))+2)sin(1–sin(2+sin(3)))+1$ 使用递归解题 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;void fun1( int , int );void fun2( int , int );int main()&#123; int n; scanf("%d", &amp;n); fun1(n , n + 1); printf("\n"); return 0;&#125;void fun2(int n, int k)&#123; if (n == k) &#123; printf("sin(%d)", n ); &#125; else &#123; printf("sin(%d", n); if( n % 2 == 0 ) &#123; printf("+"); &#125; else &#123; printf("-"); &#125; fun2(n + 1, k); printf(")"); &#125;&#125;void fun1(int n , int k)&#123; if ( n == 1 ) &#123; fun2(n , n); &#125; else &#123; printf("("); fun1(n-1, k); printf(")"); fun2(1, n); &#125; printf("+%d", k - n);&#125;]]></content>
      <categories>
        <category>蓝桥杯试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题——FJ的字符串]]></title>
    <url>%2F2019%2F02%2F17%2Flanqiao%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94FJ%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[FJ的字符串问题描述FJ在沙盘上写了这样一些字符串： A1 = “A” A2 = “ABA” A3 = “ABACABA” A4 = “ABACABADABACABA” … …你能找出其中的规律并写所有的数列AN吗？ 输入格式 仅有一个数：N ≤ 26。 输出格式请输出相应的字符串AN，以一个换行符结束。输出中不得含有多余的空格或换行、回车符。 样例输入3 样例输出ABACABA 思路 解法1 使用匹配所有下标的形式，找出所有相同字母下标的出现规律，仔细观察: A -> 2n_1 - 2 = 2^1 - (2^0 *n_1+ 1) B -> 4n_2 - 3 = 2^2 - (2^1 *n_2 + 1) C -> 8n_3- 5 = 2^3 - (2^2 *n_3+ 1) D -> 16n_4 - 9 = 2^4 - (2^3 *n_4+ 1) 又因为： n_1 = 8 = 2^3 n_2 = 4 = 2^2 n_3 = 2 = 2^1 n_4 = 1 = 2^0 所以我们只需要外层循环控制ABCD的个数，里层循环控制n的个数，就很容易得出代码。 注意点：这里使用指针字符来作为存储字符的方式，能够满足题目要求的字母个数小于26，如果要使用字符数组的话，作为局部变量可以实现数组的动态分配，但是n大于20时会导致数组内存溢出，因为局部变量的内存限制为2M，或者把字符数组当做全局变量来处理，只要初始化分配足够大的也可以处理。 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; long i,j; int n; scanf("%d",&amp;n); char *a; a = (char*)malloc(sizeof(char)*(int)(pow(2,n))-1); for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;(int)(pow(2,i));j++)&#123; a[(int)(pow(2,n-i)) * (j+1)- (int)(pow(2,n-i-1)) - 1] = 'A' + n -i - 1; &#125; &#125; for(i=0;i&lt;(int)(pow(2,n))-1;i++)&#123; printf("%c",a[i]); &#125; return 0;&#125; 思路 利用递归的方式 12345678910111213141516#include&lt;stdio.h&gt;void fun(int i) &#123; if (i==0) printf(""); else &#123; fun(i-1); printf("%c",'A'+i-1); fun(i-1); &#125;&#125;int main() &#123; int n; scanf("%d",&amp;n); fun(n); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题——芯片测试]]></title>
    <url>%2F2019%2F02%2F16%2Flanqiao%2F%E8%8A%AF%E7%89%87%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[芯片测试问题描述有n（2≤n≤20）块芯片，有好有坏，已知好芯片比坏芯片多。 每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。给出所有芯片的测试结果，问哪些芯片是好芯片。 输入格式输入数据第一行为一个整数n，表示芯片个数。 第二行到第n+1行为n*n的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行第j列（1≤i,j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本身进行测试）。 输出格式按从小到大的顺序输出所有好芯片的编号 样例输入3 1 0 1 0 1 0 1 0 1 样例输出1 3 思路：题目的前提说的是好的芯片一定大于坏的芯片，一个芯片的测试结果相当于一列，，好的芯片在一列中1的数量一定大于0的个数(或者1的数量大于一半)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;int n;int fun(int *b)&#123; int i; int y,k; y = 0; //1的个数 k = 0; //0的个数 for(i=0;i&lt;n;i++)&#123; if(b[i] == 1)&#123; y++; &#125;else&#123; k++; &#125; &#125; if(y&gt;k)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;int main()&#123; int i,j; scanf("%d",&amp;n); int a[n][n]; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; scanf("%d",&amp;a[i][j]); &#125; &#125; int b[n]; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; b[j] = a[j][i]; &#125; int t = fun(b); if(t)&#123; printf("%d ",i+1); &#125; &#125; return 0;&#125; 输出结果：]]></content>
      <categories>
        <category>蓝桥杯试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客使用bat脚本自动创建、部署、编辑和免密码部署]]></title>
    <url>%2F2019%2F02%2F16%2FHexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8bat%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%92%8C%E5%85%8D%E5%AF%86%E7%A0%81%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[原因每次写博客都要新建一个.md文件，然后把博客内存复制进去。然后执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d ，接着还要输入账号密码，这已经比较麻烦了，然后，你在博客预览的时候如果发现有些小错误，还要进行部署和输入密码一系列操作，很浪费时间。 所以，我就在windows下用bat脚本搭建了一个自动化部署的操作，解决了每次都要输入的重复操作。 脚本包括四部分：新建博客，调试，部署，查找并编辑。 一、Hexo bat脚本：1、新建博客在桌面或者文件夹中新建 CreateNewPage.bat文本。使用notepad++或者任意文本编辑器打开输入以下代码： 12345@echo offset /p name=input pages name:echo name:%name%echo please waitstart /d "F:\notepad\Notepad++" notepad++.exe "D:\Blog\blog\source\_posts\%name%.md" @echo off表示不回显，意思就是说在命令提示符中输入的命令不显示。你也可以设置为 @echo on。 set /p name=input pages name: 表示你要输入这篇博客的文件名。使用name变量存储。 12start /d &quot;F:\notepad\Notepad++&quot; notepad++.exe &quot;D:\Blog\blog\source\_posts\%name%.md&quot;表示使用这个notepad++来新建这个.md文件。 其中&quot;F:\notepad\Notepad++&quot;表示nodepad++的安装位置。D:\Blog\blog\source\_posts\%name%.md表示这个文件的存放位置。 博客路径和文本编辑器位置请改成你自己的。 如图所示： 2、调试新建debug.bat文件内容如下：1234@echo offD:cd D:\Blog\bloghexo s -debug 表示在博客根目录中运行 hexo s -debug命令。 如图所示： 3、部署新建Deploy.bat文件内容如下：1234@echo onD:cd D:\Blog\blog hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 如果你只使用的http推送的代码，需要手动输入用户名和账号的。下面讲解如果免密部署。 4、查找并编辑新建Edit.bat文件1234567891011@echo off::设置编码方式chcp 65001set /p name=input blog name: set "FileName=*%name%*.md"set "PathName=D:\Blog\blog\source\_posts"set "EditPath=F:\notepad\Notepad++"for %%a in (%PathName%) do for /f "delims=" %%b in ('dir /a-d/b/s %%a\%FileName%') do ( start /d %EditPath% notepad++.exe "%%b") 输入需要修改的文件名，会自动查找根文件夹及子文件夹下的所有文件，对文件名进行模糊匹配，匹配成功后自动使用指定的文本编辑器打开。您需要自动配置文件根目录PathName，和编辑器路径EditPath，并且把notepad++.exe修改成对应的文本编辑器可执行文件名。 二、免密码部署：打开博客根目录的config.yml，查看自己博客的部署方式：我这里部署了双平台。1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/ThinkingXuan/thinkingxuan.github.io.git,master coding: https://git.coding.net/q1454739828/q1454739828.coding.me.git,master 这是一般的部署方式，git使用https推送代码，保密性不足，所以需要输入用户名密码。所以我们需要做的改成使用ssh认证。 你需要做的就是在github或者coding中录入你自己的ssh密钥，然后在本地连接认证，一般密钥存储在id_rsa.pub文件。在C:\Users\Administrator\.ssh文件夹里面。如果你没有这个文件，请自行百度生成，连接认证。github和coding基本一样。然后修改config.yml文件：1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:ThinkingXuan/thinkingxuan.github.io.git,master coding: git@git.coding.net:q1454739828/q1454739828.coding.me.git 然后运行脚本。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>bat脚本</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题 —— 龟兔赛跑预测]]></title>
    <url>%2F2019%2F02%2F16%2Flanqiao%2F%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E9%A2%84%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[龟兔赛跑预测题目描述话说这个世界上有各种各样的兔子和乌龟，但是 研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔 子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以 上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1 米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找 到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。 输入格式输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt; =100;t&lt; =300;s&lt; =10;l&lt; =10000且为v1,v2的公倍数) 输出格式输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 样例输入10 5 5 2 20 样例输出D 4 代码如下：12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;int main()&#123; int v1,v2,t,s,l; scanf("%d %d %d %d %d",&amp;v1,&amp;v2,&amp;t,&amp;s,&amp;l); int time = 0;// 双放花费的时间 int roadv1 = 0; //兔子跑的路程 int roadv2 = 0; //乌龟跑的路程 int s2 = 0; //兔子休息的时间 while(roadv1&lt;l &amp;&amp; roadv2&lt;l)&#123; if(s2&gt;0)&#123; //乌龟跑，兔子休息，计时 s2-- ; roadv2 = roadv2 + v2; time++; &#125;else if(roadv1 - roadv2 &gt;= t)&#123; //计算兔子休息时间 s2 = s; &#125;else &#123; //乌龟和兔子都跑 roadv1 = roadv1+ v1; roadv2 = roadv2+ v2; time++; &#125; &#125; char r; if(roadv1 &gt; roadv2)&#123; r = 'R'; &#125;else if(roadv1 == roadv2)&#123; r = 'D'; &#125;else&#123; r = 'T'; &#125; printf("%c\n",r); printf("%d\n",time); return 0;&#125; 输出结果：]]></content>
      <categories>
        <category>蓝桥杯试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题 —— 回形取数]]></title>
    <url>%2F2019%2F02%2F15%2Flanqiao%2F%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0%2F</url>
    <content type="text"><![CDATA[回形取数问题描述 回形取数就是沿矩阵的边取数，若当前方向上无数可取或已经取过，则左转90度。一开始位于矩阵左上角，方向向下。 输入格式 输入第一行是两个不超过200的正整数m, n，表示矩阵的行和列。接下来m行每行n个整数，表示这个矩阵。 输出格式 输出只有一行，共mn个数，为输入矩阵回形取数得到的结果。数之间用一个空格分隔，行末不要有多余的空格。 样例输入3 3 1 2 3 4 5 6 7 8 9 样例输出1 4 7 8 9 6 3 2 5 样例输入3 2 1 2 3 4 5 6 样例输出1 3 5 6 4 2 解法思路： 按回型的方式走步，先找出二维矩阵的层数num,其实就是行和列较小值min，较小值为偶数时，num = min / 2 ,为奇数时num = min / 2 + 1,然后每一层走四步。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;void fun(int **a, int *b,int n,int m)&#123; int i,j,k,num,min,index; min = n &gt; m ? m : n; //找到n,m较小值 num = min % 2 == 0 ? min / 2 : min / 2 + 1; //计算循环次数 index = 0; for(k=0;k&lt;num;k++)&#123; //往下 j = k; for(i=k;i&lt;n-1;i++)&#123; b[index++] = *((int*)a + m*i + j); &#125; //往右 for(j=0;j&lt;m-1;j++)&#123; b[index++] = *((int*)a + m*i + j); &#125; //往上 for(;i&gt;0;i--)&#123; b[index++] = *((int*)a + m*i + j); &#125; //往左 for(;j&gt;0;j--)&#123; b[index++] = *((int*)a + m*i + j); &#125; &#125; &#125;int main()&#123; int n,m,i,j; scanf("%d %d",&amp;n,&amp;m); int a[n][m]; int b[n*m]; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; scanf("%d",&amp;a[i][j]); &#125; &#125; fun(a,b,n,m); for(i=0;i&lt;n*m;i++)&#123; printf("%d ",b[i]); &#125; return 0;&#125; 输出结果：]]></content>
      <categories>
        <category>蓝桥杯试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法入门 —— 报时助手]]></title>
    <url>%2F2019%2F02%2F15%2Flanqiao%2Fbasic8%2F</url>
    <content type="text"><![CDATA[报时助手问题描述&emsp;&emsp;给定当前的时间，请用英文的读法将它读出来。时间用时h和分m表示，在英文的读法中，读一个时间的方法是：如果m为0，则将时读出来，然后加上“o’clock”，如3:00读作“three o’clock”。如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five thirty”。&emsp;&emsp;时和分的读法使用的是英文数字的读法，其中0~20读作：0:zero, 1: one, 2:two, 3:three, 4:four, 5:five, 6:six, 7:seven, 8:eight, 9:nine, 10:ten, 11:eleven, 12:twelve, 13:thirteen, 14:fourteen,15:fifteen, 16:sixteen, 17:seventeen, 18:eighteen, 19:nineteen, 20:twenty。30读作thirty，40读作forty，50读作fifty。 &emsp;&emsp;对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty one”。按上面的规则21:54读作“twenty one fifty four”，9:07读作“nine seven”，0:15读作“zero fifteen”。 输入格式输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。 输出格式输出时间时刻的英文。 样例输入0 15 样例输出zero fifteen 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;stdio.h&gt;void timePrint(int i)&#123; char* a[24] = &#123;"zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven", "twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen","twenty", "thirty","forty","fifty"&#125;; printf("%s",a[i]);&#125;int main()&#123; int a,b; scanf("%d %d",&amp;a,&amp;b); if(a&gt;=0 &amp;&amp; a&lt;=20 )&#123; timePrint(a); &#125;else&#123; timePrint(20); printf(" "); timePrint(b%10); &#125; printf(" "); if(b==0)&#123; printf("o'clock"); &#125;else if(b&lt;=20)&#123; timePrint(b); &#125;else if(b&lt;30)&#123; timePrint(20); printf(" "); timePrint(b%10); &#125;else if(b==30)&#123; timePrint(21); &#125;else if(b&lt;40)&#123; timePrint(21); printf(" "); timePrint(b%10); &#125;else if(b==40)&#123; timePrint(22); &#125;else if(b&lt;50)&#123; timePrint(22); printf(" "); timePrint(b%10); &#125;else if(b == 50)&#123; timePrint(23); printf(" "); &#125;else&#123; timePrint(23); printf(" "); timePrint(b%10); &#125; return 0;&#125; 输出结果：]]></content>
      <categories>
        <category>蓝桥杯试题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法入门 —— 2N皇后问题]]></title>
    <url>%2F2019%2F02%2F14%2Flanqiao%2Fbasic7%2F</url>
    <content type="text"><![CDATA[2n皇后问题 这个题目是经典题目N皇后的延伸，如果您对N皇后还不太了解，请点击这。 问题描述 给定一个 n*n 的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 输入格式 输入的第一行为一个整数n，表示棋盘的大小。 接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 输出格式 输出一个整数，表示总共有多少种放法。 样例输入4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 样例输出2 样例输入4 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 样例输出0 题目讲解&emsp;&emsp;看过上一篇的同学们，应该知道用递归解决N皇后的具体方法，通过一个二维数组的第一列或者直接用一个一维数组存储每一行中皇后的位置。本题中，需要放置两个不同类型的皇后，我的思路是先放黑皇后，然后放白皇后。这个两个皇后的放法其实大同小异，但是当我们放置完黑皇后只后，需要保持黑皇后放置的状态，这里我使用二维数组status来保存，放置黑皇后的位置置1，当递归的一个流程执行完成后，然后把这个位置置0，进行第二次递归。 &emsp;&emsp;这个为了简化流程，我用两个一维数组来保存两个皇后在对应行中的放置位置。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;//a 存储棋盘情况 status存储黑皇后的放置情况 b存储黑皇后对应行的放置位置 w存储白皇后对应行的放置位置 int a[11][11],status[11][11],b[11],w[11];int num,n;//判断是否合适 (不在同一列，不在同一对角线) int isLegal(int * b, int x, int y)&#123; int i; for(i=0;i&lt;x;i++)&#123; if(b[i] == y || abs(x-i) == abs(y - b[i]))&#123; return 0; &#125; &#125; return 1;&#125;//搜索二维数组，放置白皇后 void DFSWhite(int row)&#123; if(row == n)&#123; num++; return; &#125;else&#123; int i; for(i=0;i&lt;n;i++)&#123; //判断该位置可以放置白皇后 ，且这个位置不能有黑皇后 if(a[row][i]!=0 &amp;&amp; status[row][i]==0 &amp;&amp; isLegal(w,row,i))&#123; w[row] = i; DFSWhite(row+1); &#125; &#125; &#125;&#125; //搜索二维数组，先放置黑皇后void DFSBlack(int row)&#123; if(row == n)&#123; //黑皇后放置完成，放置白皇后 DFSWhite(0); return; &#125;else&#123; int i; for(i=0;i&lt;n;i++)&#123; //判断该位置可以放置皇后 if(a[row][i]!=0 &amp;&amp; isLegal(b,row,i))&#123; b[row] = i; status[row][i] = 1; //放置黑皇后的位置置1 DFSBlack(row+1); status[row][i] = 0; // 两类皇后的放置，把黑皇后的这个位置的 置0 &#125; &#125; &#125;&#125; int main()&#123; int i,j; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; scanf("%d",&amp;a[i][j]); status[i][j] = 0; &#125; &#125; for(i=0;i&lt;n;i++)&#123; b[i] = 0; w[i] = 0; &#125; DFSBlack(0); printf("%d",num); return 0; &#125; 输出结果： 更多测试用例： input 13 1 1 0 1 1 1 1 1 0 output10 input241 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 output22 input 351 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 output312 input461 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 output412 input571 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 output408]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
        <tag>深度优先搜索</tag>
        <tag>2N皇后</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法入门 —— N皇后问题]]></title>
    <url>%2F2019%2F02%2F14%2Flanqiao%2Fbasic6%2F</url>
    <content type="text"><![CDATA[题目描述&emsp;&emsp;在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 &emsp;&emsp;如图所示，这是个4*4棋盘皇后的放置方法： 解决方法1：&emsp;&emsp;解决N皇后的问题，一般都是采用递归搜索的方式，普通暴力方法太耗时，不在本文章的讨论范围之内。 1、搜索所有位置：&emsp;&emsp;若想遍历所有摆法而无一遗漏，可以逐行先从左至右，在从上至下（按行搜索，一行搜索完或者找到一个可以放置皇后的位置就换行）尝试棋子的摆放，方法名为DFS()。 2、判断是否可以摆放：&emsp;&emsp;每次分配的棋盘多出一行和一列，第一列存储所在行的皇后放置的位置。如a[2][0] = 2 ,表示皇后放置在第3行的第3列(从0开始计算)， 方法名为isLegal()。 &emsp;&emsp;因为采用的是按行搜索，判断本位置可以放置皇后就换行，所以不会出现一行出现多个皇后， 因而只需判断列和对角线。 (1) 不在同一列：对比第一列中的元素（a[i][0]）。(2) 不在对角线：即有两棋子坐标分别为(X1,Y1),(X2,Y2)，则|X1-X2|!=|Y1-Y2| 3、搜索流程所以总共能搜索出两种情况。如题目描述中。 4、递归流程&emsp;&emsp;当每一个流程执行同之后，代表一个情况，这里，用 row = n +1 = 5(开始寻找第五行时)是作为递归的结束条件。 5、代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;//N皇后问题int a[11][11]; //皇后其棋盘，第一行和第一列来存储 每一行的皇后的列坐标int b[11]; //打表所用的数组int N;int num;//判断第x行第y列放置皇后是否合法。int isLegal(int x,int y) &#123; int i; for(i=1; i&lt;x; i++) &#123; if(a[i][0] == y || abs(x-i) == abs(y-a[i][0])) &#123; //在同一列或者同一对角线 return 0; &#125; &#125; return 1;&#125;void print(int n)&#123; int i,j; for(i=1;i&lt;n+1;i++)&#123; for(j=1;j&lt;n+1;j++)&#123; if(j == a[i][0])&#123; printf("1 "); &#125;else&#123; printf("0 "); &#125; &#125; printf("\n"); &#125; printf("\n");&#125;void DFS(int row,int m) &#123; //n代表搜索到第几行，m代表皇后的数量 if(row == m+1) &#123; //搜索结束条件(皇后放置完成) num++; print(m); &#125; else &#123; int i; for(i=1; i&lt;=m; i++) &#123; if(isLegal(row,i)) &#123; a[row][0] = i; DFS(row+1,m); &#125; &#125; &#125;&#125;int main() &#123; int i; for(i=1; i&lt;6; i++) &#123; num = 0; printf("%d * %d 时\n",i,i); DFS(1,i); b[i] = num; printf("共有%d种情况\n\n",num); &#125; return 0;&#125; 输出结果： 解决方法2：空间复杂度优化&emsp;&emsp;因为二维数组里面并不是真的存储皇后，只是便于理解而已，真正用到的存储空间只有二维数组中的第一列。正好使用一个一维数组表示，这样空间复杂度从O(n ^2) 降到了 n。代码中只需把所有有关二维数组后面[]去掉即可。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;//N皇后问题int a[11]; //皇后其棋盘，相当于二维数组中的第一列，只存储本行皇后的放置位置 int b[11]; //打表所用的数组int N;int num;//判断第x行第y列放置皇后是否合法。int isLegal(int x,int y) &#123; int i; for(i=1; i&lt;x; i++) &#123; if(a[i] == y || abs(x-i) == abs(y-a[i])) &#123; //在同一列或者同一对角线 return 0; &#125; &#125; return 1;&#125;void print(int n)&#123; int i,j; for(i=1;i&lt;n+1;i++)&#123; for(j=1;j&lt;n+1;j++)&#123; if(j == a[i])&#123; printf("1 "); &#125;else&#123; printf("0 "); &#125; &#125; printf("\n"); &#125; printf("\n");&#125;void DFS(int row,int m) &#123; //n代表搜索到第几行，m代表皇后的数量 if(row == m+1) &#123; //搜索结束条件(皇后放置完成) num++; print(m); &#125; else &#123; int i; for(i=1; i&lt;=m; i++) &#123; if(isLegal(row,i)) &#123; a[row] = i; DFS(row+1,m); &#125; &#125; &#125;&#125;int main() &#123; int i; for(i=1; i&lt;6; i++) &#123; num = 0; printf("%d * %d 时\n",i,i); DFS(1,i); b[i] = num; printf("共有%d种情况\n\n",num); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>N皇后</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题——基础练习16]]></title>
    <url>%2F2019%2F02%2F13%2Flanqiao%2Fbasic5%2F</url>
    <content type="text"><![CDATA[1、Huffuman树 问题描述 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa +pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9,5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入格式 输入的第一行包含一个正整数n（n&lt;=100）。 接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。 输出格式 输出用这些数构造Huffman树的总费用。 样例输入55 3 8 2 9 样例输出59 代码如下：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;void sort(int arr[],int length)&#123; int i,j; for(i=0;i&lt;length;i++) &#123; for(j=i;j&lt;length;j++)&#123; if(arr[i]&gt;arr[j])&#123; int t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; &#125;&#125;int main()&#123; int n,i,sum,j; scanf("%d",&amp;n); int arr[n]; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;arr[i]); &#125; sort(arr,n); // j = 0; sum = 0; while(j&lt;n-1)&#123; sum = sum + arr[j] + arr[j+1]; arr[j+1] = arr[j] + arr[j+1]; arr[j] = -1; sort(arr,n); j++; &#125; printf("%d\n",sum); return 0;&#125; 2、2n皇后问题问题描述 给定一个n*n的棋盘，棋盘中有一些位置不能放皇后。现在要向棋盘中放入n个黑皇后和n个白皇后，使任意的两个黑皇后都不在同一行、同一列或同一条对角线上，任意的两个白皇后都不在同一行、同一列或同一条对角线上。问总共有多少种放法？n小于等于8。 输入格式 输入的第一行为一个整数n，表示棋盘的大小。 接下来n行，每行n个0或1的整数，如果一个整数为1，表示对应的位置可以放皇后，如果一个整数为0，表示对应的位置不可以放皇后。 输出格式 输出一个整数，表示总共有多少种放法。 样例输入4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 样例输出2 样例输入4 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 样例输出0 篇幅较长，详见下一篇]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题——基础练习11-15]]></title>
    <url>%2F2019%2F01%2F27%2Flanqiao%2Fbasic4%2F</url>
    <content type="text"><![CDATA[1、字母图形2、01字串3、闰年判断4、阶乘计算5、高精度加法 1、字母图形问题描述利用字母可以组成一些美丽的图形，下面给出了一个例子： ABCDEFG BABCDEF CBABCDE DCBABCD EDCBABC 这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。 输入格式输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。 输出格式输出n行，每个m个字符，为你的图形。 样例输入5 7 样例输出ABCDEFG BABCDEF CBABCDE DCBABCD EDCBABC 数据规模与约定1 &lt;= n, m &lt;= 26。 代码如下：123456789101112131415#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123; int i,j,n,m; scanf("%d %d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; printf("%c",abs(i-j)+65); &#125; printf("\n"); &#125; return 0;&#125; 2、01字串问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是： 00000 00001 00010 00011 00100 请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 样例输出00000 00001 00010 00011 &lt;以下部分省略&gt; 分析：仔细观察可以想到输出的顺序其实就是0-31的二进制表示，所以可以遍历0-31，求二进制求解。题目规定的精度也不高，直接int存储二进制就可以了,前面的补0,可以使用C语言的%05d格式化输出。 代码如下：123456789101112131415161718192021#include&lt;stdio.h&gt;int fun(int n)&#123; int i; int t = 0; int b = 1; while(n)&#123; i = n % 2; t = t + i *b; n = n / 2; b = b * 10; &#125; return t;&#125; int main()&#123; int i; for(i=0;i&lt;32;i++)&#123; printf("%05d\n",fun(i)); &#125; return 0;&#125; 3、闰年判断问题描述给定一个年份，判断这一年是不是闰年。 当以下情况之一满足时，这一年是闰年： 年份是4的倍数而不是100的倍数； 年份是400的倍数。 其他的年份都不是闰年。 输入格式输入包含一个整数y，表示当前的年份。 输出格式输出一行，如果给定的年份是闰年，则输出yes，否则输出no。说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。 样例输入2013 样例输出no 样例输入2016 样例输出yes 数据规模与约定1990 &lt;= y &lt;= 2050。 代码如下：1234567891011#include&lt;stdio.h&gt;int main()&#123; int year; scanf("%d",&amp;year); if(year%400==0 || (year%100!=0 &amp;&amp; year%4==0))&#123; printf("yes\n"); &#125;else&#123; printf("no\n"); &#125; return 0;&#125; 4、阶乘计算问题描述 输入一个正整数n，输出n!的值。 其中n!=1*2*3*…*n。 算法描述 n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。 将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。 首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。 输入格式 输入包含一个正整数n，n&lt;=1000。 输出格式 输出n!的准确值。 样例输入10 样例输出3628800 代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;int main()&#123; int n,i,j,t,k = 0; j = 0; scanf("%d",&amp;n); int arr[10000]; arr[0] = 1; arr[1] = -1; //-1 记录末尾 for(i=1;i&lt;=n;i++)&#123; j = 0; k = 0; while(arr[j]!=-1)&#123; //使用 i * arr[j] t = arr[j] * i + k; // k存储上次进位 if(t&lt;10)&#123; arr[j] = t; k = 0; &#125; else&#123; arr[j] = t % 10; k = t / 10; &#125; j++; &#125; //处理最后一次进位k ,k有可能很大，所有用循环赋值。 if(k&gt;0)&#123; while(k)&#123; arr[j++] = k % 10; k = k / 10; &#125; arr[j] = -1; &#125; &#125; // 用i指向末尾 i =0; while(arr[i]!=-1)&#123; i++; &#125; for(j = i-1;j&gt;=0;j--)&#123; printf("%d",arr[j]); &#125; printf("\n"); return 0;&#125; 5、高精度加法问题描述 输入两个整数a和b，输出这两个整数的和。a和b都不超过100位。 算法描述 由于a和b都比较大，所以不能直接使用语言中的标准数据类型来存储。对于这种问题，一般使用数组来处理。 定义一个数组A，A[0]用于存储a的个位，A[1]用于存储a的十位，依此类推。同样可以用一个数组B来存储b。 计算c = a + b的时候，首先将A[0]与B[0]相加，如果有进位产生，则把进位（即和的十位数）存入r，把和的个位数存入C[0]，即C[0]等于(A[0]+B[0])%10。然后计算A[1]与B[1]相加，这时还应将低位进上来的值r也加起来，即C[1]应该是A[1]、B[1]和r三个数的和．如果又有进位产生，则仍可将新的进位存入到r中，和的个位存到C[1]中。依此类推，即可求出C的所有位。 最后将C输出即可。 输入格式 输入包括两行，第一行为一个非负整数a，第二行为一个非负整数b。两个整数都不超过100位，两数的最高位都不是0。 输出格式 输出一行，表示a + b的值。 样例输入20100122201001221234567890 2010012220100122 样例输出20100122203011233454668012 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; char arr1[101]; char arr2[101]; int sum[101]; scanf("%s", arr1); scanf("%s", arr2); //记录两个字符长度 int len1 = strlen(arr1); int len2 = strlen(arr2); //记录最大长度，方便输出 int max = len1 &gt; len2 ? len1 : len2; //sum的下标(因为必须从后往前加) int index = max - 1; //arr1的下标 int i = len1 - 1; //arr2的下标 int j = len2 - 1; //相加时的中间数 int t, k = 0; while (i &gt;= 0 || j &gt;= 0) &#123; if(i&lt;0)&#123; //第一个数组遍历完成 t = arr2[j] - '0' + k; j--; &#125; else if (j&lt;0)&#123; //第二个数组遍历完成 t = arr1[i] - '0' + k; i--; &#125;else&#123; //两个数组同时遍历 t = arr1[i] - '0' + arr2[j] - '0' + k; i--; j--; &#125; //相加处理 if (t &lt; 10) &#123; sum[index--] = t; k = 0; &#125; else &#123; sum[index--] = t % 10; k = t / 10; &#125; &#125; //先输出k，因为这有可能是进位数 if(k&gt;0)&#123; printf("%d",k); &#125; for (i = 0; i &lt; max; i++) &#123; printf("%d", sum[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题——基础练习6-10]]></title>
    <url>%2F2019%2F01%2F26%2Flanqiao%2Fbasic3%2F</url>
    <content type="text"><![CDATA[1、 回文数问题描述 1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。 输出格式 按从小到大的顺序输出满足条件的四位十进制数。 代码如下：12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int fun(int i)&#123; int t; int a = i; t = 0; while(i)&#123; t = i % 10 + t * 10; i = i / 10; &#125; if(t == a)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;int main()&#123; int i; for(i=1000;i&lt;10000;i++)&#123; if(fun(i))&#123; printf("%d\n",i); &#125; &#125; return 0;&#125; 2、特殊的数字问题描述 153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1*1*1+5*5*5+3*3*3。编程求所有满足这种条件的三位十进制数。 输出格式 按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。 代码如下：123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int i; int a,b,c; for(i=100;i&lt;1000;i++)&#123; a = i / 100; b = i / 10 % 10; c = i % 10; if((a*a*a+b*b*b+c*c*c) == i)&#123; printf("%d\n",i); &#125; &#125; return 0;&#125; 3、杨辉三角形问题描述杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。 下面给出了杨辉三角形的前4行： 1 1 1 1 2 1 1 3 3 1 给出n，输出它的前n行。 输入格式输入包含一个数n。 输出格式输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。 样例输入4 样例输出1 1 1 1 2 1 1 3 3 1 数据规模与约定1 &lt;= n &lt;= 34。 分析：直接用两层循环不是很好找规律，因为是内部数与数之间的关系，所以使用二维数组。 代码如下：12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main()&#123; int i,j,n; scanf("%d",&amp;n); int arr[n][n]; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; if(j==0||i==j)&#123; arr[i][j] = 1; &#125;else if(i&gt;j)&#123; arr[i][j] = arr[i-1][j] + arr[i-1][j-1]; &#125; &#125; &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; if(i&gt;=j)&#123; printf("%d ",arr[i][j]); &#125; &#125; printf("\n"); &#125; return 0;&#125; 4、查找整数问题描述给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。 输入格式第一行包含一个整数n。 第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。 第三行包含一个整数a，为待查找的数。 输出格式如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。 样例输入6 1 9 4 8 3 9 9 样例输出2 数据规模与约定1 &lt;= n &lt;= 1000。 代码如下：12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int n,i,a; int index = -1; scanf("%d",&amp;n); int arr[n]; for(i=0;i&lt;n;i++)&#123; scanf("%d ",&amp;arr[i]); &#125; scanf("%d",&amp;a); for(i=0;i&lt;n;i++)&#123; if(a == arr[i])&#123; index = i + 1; break; &#125; &#125; printf("%d\n",index); return 0;&#125; 5、数列特征问题描述给出n个数，找出这n个数的最大值，最小值，和。 输入格式第一行为整数n，表示数的个数。 第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。 输出格式输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。 样例输入5 1 3 -2 4 5 样例输出5 -2 11 数据规模与约定1 &lt;= n &lt;= 10000。 代码如下：12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int main()&#123; int n,i,max,min,sum; sum = 0; scanf("%d",&amp;n); int arr[n]; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;arr[i]); if(i==0)&#123; max = arr[i]; min = arr[i]; sum = arr[i]; &#125;else&#123; sum = sum + arr[i]; if(arr[i]&gt;max)&#123; max = arr[i]; &#125; if(arr[i]&lt;min)&#123; min = arr[i]; &#125; &#125; &#125; printf("%d\n%d\n%d\n",max,min,sum); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题——基础练习1-5]]></title>
    <url>%2F2019%2F01%2F26%2Flanqiao%2Fbasic2%2F</url>
    <content type="text"><![CDATA[1、数列排序问题描述 给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1&lt;=n&lt;=200 输入格式 第一行为一个整数n。 第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。 输出格式 输出一行，按从小到大的顺序输出排序后的数列。代码如下：1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;void sort(int array[],int length)&#123; int i,j; for(i=0;i&lt;length-1;i++)&#123; for(j=i+1;j&lt;length;j++)&#123; if(array[i]&gt;array[j])&#123; int t = array[i]; array[i] = array[j]; array[j] = t; &#125; &#125; &#125;&#125;int main()&#123; int n,i; scanf("%d",&amp;n); int array[n]; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;array[i]); &#125; sort(array,n); for(i=0;i&lt;n;i++)&#123; printf("%d ",array[i]); &#125; return 0;&#125; 2、十六进制转八进制问题描述 给定n个十六进制正整数，输出它们对应的八进制数。 输入格式 输入的第一行为一个正整数n （1&lt;=n&lt;=10）。 接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。 输出格式 输出n行，每行为输入对应的八进制正整数。 【注意】 输入的十六进制数不会有前导0，比如012A。 输出的八进制数也不能有前导0。 样例输入 2 39 123ABC 样例输出 71 4435274 分析：题目规定输入的十六进制数长度要低于100000，转换为二进制长度就是要兼容400000，使用long long 也根本无法兼容。所以使用字符串来存储16进制数，转换为二进制也用字符串。最后把二进制转为8进制。 简单做法(不符合题意)：1234567891011#include&lt;stdio.h&gt;int main()&#123; int n,i; long long t; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%I64x",&amp;t); printf("%I64o\n",t); &#125; return 0;&#125; 正确做法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;string.h&gt; int main()&#123; char s[500000]; //存储输入的16进制数 int n,i,j; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%s",s); int len = strlen(s); char p[len*4]; //存储输入的16进制数对应的二进制 convet16to2(s,p); convert2to8(p,len*4); &#125; return 0;&#125;//把十六进制转换为二进制void convet16to2(char *s,char *p)&#123; int length = strlen(s); //获取输入的长度 int i; char *t; int j=0; p[0] = '\0'; for(i=0;i&lt;length;i++)&#123; switch(s[i])&#123; case '0':t = "0000";break; case '1':t = "0001";break; case '2':t = "0010";break; case '3':t = "0011";break; case '4':t = "0100";break; case '5':t = "0101";break; case '6':t = "0110";break; case '7':t = "0111";break; case '8':t = "1000";break; case '9':t = "1001";break; case 'A':t = "1010";break; case 'B':t = "1011";break; case 'C':t = "1100";break; case 'D':t = "1101";break; case 'E':t = "1110";break; case 'F':t = "1111";break; &#125; strcat(p,t); &#125;&#125; //把二进制进制转换为八进制 421void convert2to8(char c[],int length)&#123; int i,j=0; int len8 =length%3==0?length/3:length/3+1; int d[len8]; //存储8进制 for(i=length-1;i&gt;0;i=i-3)&#123; int a; if(i==0)&#123; a = (c[i] - 48); &#125;else if(i==1)&#123; a = (c[i-1] - 48)*10 + (c[i] - 48); &#125;else &#123; a = (c[i-2] - 48) *100 + (c[i-1] - 48)*10 + (c[i] - 48); &#125; int t; switch(a)&#123; case 0: t=0;break; case 1: t=1;break; case 10: t=2;break; case 11: t=3;break; case 100: t=4;break; case 101: t=5;break; case 110: t=6;break; case 111: t=7;break; &#125; d[j++] = t; &#125; for(j=j-1;j&gt;=0;j--)&#123; printf("%d",d[j]); &#125; printf("\n"); &#125; 3、十六进制转十进制问题描述 从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。 注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。 样例输入FFFF 样例输出65535 题目要求的精度比较低，较为简单 代码如下：12345678#include&lt;stdio.h&gt;int main()&#123; long long a; scanf("%I64x",&amp;a); printf("%I64d\n",a); return 0;&#125; 4、十进制转十六进制问题描述 十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。 给出一个非负整数，将它表示成十六进制的形式。 输入格式 输入包含一个非负整数a，表示要转换的数。0&lt;=a&lt;=2147483647 输出格式 输出这个整数的16进制表示 分析：题目要求的精度比较低，较为简单 1234567#include&lt;stdio.h&gt;int main()&#123; long long a; scanf("%I64d",&amp;a); printf("%I64X\n",a); return 0;&#125; 5、特殊回文数问题描述 123321是一个非常特殊的数，它从左边读和从右边读是一样的。 输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 输入格式 输入一行，包含一个正整数n。 输出格式 按从小到大的顺序输出满足条件的整数，每个整数占一行。 样例输入 52 样例输出 899998 989989 998899 数据规模和约定 1&lt;=n&lt;=54。 分析：这题比较比较容易，题目要求五位和六位数，就是在[10000,1000000)之间，先判断是否是回文，然后在判断位数上的数相加是否等于n即可。代码如下：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;//判断是否是回文数 int fun(int a)&#123; int b = a; int t = 0; while(a&gt;0)&#123; t = t * 10 + a % 10; a = a / 10; &#125; if(b == t)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;//计算个个位数上的数相加和 int fun2(int a)&#123; int sum = 0; int t; while(a)&#123; t = a %10; sum = sum + t; a = a / 10; &#125; return sum;&#125;int main()&#123; int n; scanf("%d",&amp;n); int i; for(i=10000;i&lt;1000000;i++)&#123; if(fun(i)&amp;&amp;fun2(i)==n )&#123; printf("%d\n",i); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯试题——基础篇]]></title>
    <url>%2F2019%2F01%2F24%2Flanqiao%2Fbasic%2F</url>
    <content type="text"><![CDATA[1、 A+B问题问题描述输入A、B，输出A+B。 输入格式输入的第一行包括两个整数，由空格分隔，分别表示A、B。 输出格式输出一行，包括一个整数，表示A+B的值。代码：12345678#include &lt;stdio.h&gt; int main()&#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%d", a+b); return 0;&#125; 2、序列求和问题描述求1+2+3+…+n的值。 输入格式输入包括一个整数n。 输出格式输出一行，包括一个整数，表示1+2+3+…+n的值。 数据规模与约定1 &lt;= n &lt;= 1,000,000,000。 分析：因为n要求的数据规模很大，所以直接循环累加的方式不能满足要求，所以采用求等差数列前n和公式 S(n) = \frac{(a_1 + a_n)*n}{2} 代码：123456789#include&lt;stdio.h&gt;int main()&#123; long long sum = 0; long long n,i; scanf("%d",&amp;n); sum = ((1+n) * n)/2; printf("%I64d\n",sum); return 0;&#125; 3、圆的面积问题描述给定圆的半径r，求圆的面积。 输入格式输入包含一个整数r，表示圆的半径。 输出格式输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。 数据规模与约定1 &lt;= r &lt;= 10000。 提示本题对精度要求较高，请注意π的值应该取较精确的值。你可以使用常量来表示π，比如PI=3.14159265358979323，也可以使用数学公式来求π，比如PI=atan(1.0)*4。 代码：12345678910#include&lt;stdio.h&gt;int main()&#123; int r; scanf("%d",&amp;r); double PI=3.14159265358979323; double c = r * r * PI; printf("%.7lf\n",c); return 0;&#125; 4、Fibonacci数列问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 数据规模与约定1 &lt;= n &lt;= 1,000,000。 解析：直接通过Fn=Fn-1+Fn-2 累加 求第Fn个数，然后取余，n增大时，数会变得很大，超过了C语言规定的长度。所以看提示:求取余的结果累加。 代码如下：1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; long a,b,n; a = 1; b = 0; long sum = 1; scanf("%ld",&amp;n); long i; for(i=0;i&lt;n;i++)&#123; sum = (a + b)%10007; a = b; b = sum; &#125; printf("%ld ",sum); return 0;&#125;]]></content>
      <categories>
        <category>蓝桥杯</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>蓝桥杯试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(四)——字符串的模式匹配]]></title>
    <url>%2F2019%2F01%2F24%2FDataStructure%2FdataStructure7%2F</url>
    <content type="text"><![CDATA[1、字符串匹配的用处&emsp;&emsp;在进行字符串操作，经常会出现定位操作，比如寻找字符串p是否在字符串s中，存在则返回p在s中第一个字符出现的下标。我们把串s称为主串，把串p称为模式串。一些语言中也内置了这个函数，比如C语言中头文件string.h中strstr()方法，Java中的indexOf()方法。本篇文章用3种方法来讲解这个算法的实现。 2、匹配方法：2.1 朴素的模式匹配：&emsp;&emsp;又称(Brute Force)，其实就是暴力破解的意思。具体思路是同时遍历主串和模式串，先比较s和p的第一个字符，如果相等继续比较第二个字符，如果不相等，s从第二个字符开始比较p的第一个字符。如果相等，继续往下比较，如果不相等，s从第三个字符开始比较p的第一个字符，以此类推，直到模式串第一次匹配完毕终止。 &emsp;&emsp;用i表示主串s下标，用j表示模式串p下标。字符相等时就i++; j++;,不相等是就 i = i - j + 1; j=0; 如图所示： &emsp;&emsp;当s[3]!=p[2]时，因为这次比较是从i=1开始比较的，所以i要回溯到i=2 也就是 i = i - j + 1, j要回溯到j = 0。代码如下：12345678910111213141516171819202122//暴力破解法int search(char *s, char *p)&#123; int lens = strlen(s); int lenp = strlen(p); int i=0,j=0; while(i&lt;lens &amp;&amp; j&lt;lenp)&#123; if(s[i]!=p[j])&#123; i = i - j + 1; //主串从下一个位置开始 j = 0; //模式串从0开始 &#125;else&#123; i++; j++; &#125; &#125; if(j==lenp)&#123; //匹配成功 return i-j; //j代表p的长度减1 , i为s中搜索的字符个数减1 。i-j为p在s中匹配成功后第一个字符的开始下标 &#125;else&#123; //没有匹配成功 return -1; &#125;&#125; 时间复杂度：O(n*m) 2.2 动态规划算法：&emsp;&emsp;使用二维数组记录匹配的所有情况，如图所示： &emsp;&emsp;先匹配第一行，第一列。相等记为1，不等记为0。然后往里比较，如果相等，取主对角线的前一位加一,不等记为0。等数组中出现的数字也模式串p的长度相等时，匹配结束。代码如下：1234567891011121314151617181920212223242526272829//动态规划 int dynamicSearch(char *s,char *p)&#123; int lens = strlen(s); int lenp = strlen(p); int temp[lens][lenp]; int i,j; for(i=0;i&lt;lens;i++)&#123; for(j=0;j&lt;lenp;j++)&#123; if(j==0||i==0)&#123; if(p[j] == s[i])&#123; temp[i][j] = 1; &#125;else&#123; temp[i][j] = 0; &#125; &#125;else&#123; if(p[j] == s[i])&#123; temp[i][j] = temp[i-1][j-1] + 1; &#125;else&#123; temp[i][j] = 0; &#125; &#125; if(temp[i][j] == lenp)&#123; return i - lenp + 1; &#125; &#125; &#125; return -1;&#125; 算法复杂度：O(n*m) 2.3 KMP算法：&emsp;&emsp;当模式串为p = &quot;abcabd&quot;，主串为s = &quot;abcabgabey&quot;时，如图所示： &emsp;&emsp;当s[5]!=p[5],如果按照之前的方法，i要回溯到1，p要回溯到0，但是仔细想想，真的有这个必要吗？观察p串，有相同子符ab。推出： p[0] = p[3] 且 p[1] = p[4] p[3] = s[3] 且 p[4] = s[4] => p[0] = s[3] 且p[1] = s[4] &emsp;&emsp;所以，i不需要回溯，只需对比p[2] 是否等于 s[5],这样i直接从0跳到了5，省略了许多不必要的重复步骤。那么问题的关键就是如何确定p匹配失败时j回到哪一个最恰当的位置。仔细观察一下，只有出现重复子串时，才会出现这种情况。如果没有重复子串,j只能取0。 &emsp;&emsp;它的效率提高的地方是无需回溯s的下标i，只需回溯j，匹配时，直接i++，j找到合适的位置，依次比对下去。 &emsp;&emsp;那如何找到j的恰当位置呢，这时要引入一个整形数组next[]，next下标与p的下标对应，存储是的是这个 字符之前(不包含自己) 的子串的前缀和后缀(包含最后一个字符的子串)相等时字符的个数。 前缀(包含第一个字符的子串) 后缀(包含最后一个字符的子串) 其中 规定next[0] = -1，所以 p = &quot;abcabd&quot; 对应的next数组为next= [-1,0,0,0,1,2]，这样其实就已经结束了，但是为了追求更少的对比次数。可以把next数组在优化一下。因为p[3] = p[0] = &#39;a&#39;,p[3]之前的字符不重复， 所以无需取j,直接让i继续走。所以`next= [-1,0,0,-1,0,2]; 2.3.1 求Next数组：12345678910111213141516171819202122void getNext(char* p, int next[])&#123; int pLen = strlen(p); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1)&#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k])&#123; ++j; ++k; //较之前next数组求法，改动在下面4行 if (p[j] != p[k]) next[j] = k; //之前只有这一行 else //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k]; &#125; else&#123; k = next[k]; &#125; &#125;&#125; 2.3.2 KMP算法代码：1234567891011121314151617181920int kmpSearch(char *s,char *p)&#123; int lens = strlen(s); int lenp = strlen(p); int next[lenp]; getNext(p,next); int i=0,j=0; while(i&lt;lens &amp;&amp; j&lt;lenp)&#123; if(j==-1||s[i]==p[j])&#123; i++; j++; &#125;else&#123; j = next[j]; &#125; &#125; if(j==lenp)&#123; return i-j; &#125;else&#123; return -1; &#125;&#125; 算法复杂度 O(n+m) 3、测试123456789101112131415161718int main()&#123; char *s = "abcabgabcabay"; char *p = "abcaba"; printf("s = \"abcabgabcabay\" p = \"abcaba\"\n"); printf("朴素的模式匹配：\n"); int pos = search(s,p); printf("pos = %d\n",pos); printf("动态规划算法：\n"); pos = kmpSearch(s,p); printf("pos = %d\n",pos); printf("KMP算法：\n"); pos = dynamicSearch(s,p); printf("pos = %d\n",pos); return 0;&#125; 输出结果： 4、总结&emsp;&emsp;综合来说这三种方法各有优劣，如果追求效率的话，KMP算法最好，算法复杂度最低，但是也难理解。如果您感觉KMP算法效率还是不符合您的要求，请点击这里，里面介绍了BM算法和Sunday算法，效率更好，算法复杂度减少到了O(n)。 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(四)——串]]></title>
    <url>%2F2019%2F01%2F22%2FDataStructure%2FdataStructure6%2F</url>
    <content type="text"><![CDATA[1、什么是串&emsp;&emsp;串又称字符串，是比较常见的一个数据结构，它由0或多个字符构成，一般定义为s=&quot;abcdegf&quot;。字符的个数称为串的长度。长度为0的串为空串，记为s=&quot;&quot;，由空格组成的串为空格串，空格也是字符，记为s=&quot; &quot;。&emsp;&emsp;目前，随着科学技术的发展，非数值处理的情况越来越多，学好字符串的处理变得尤为重要，本文将介绍字符串处理的几个基本方法。 2、串的顺序存储&emsp;&emsp;在串的顺序存储结构中，用一组地址连续的空间，即数组来存储字符串中的字符，串中的每一个字符占据一个空间，如图所示： 2.1 创建和赋值1234567891011121314151617181920212223242526//创建String类型typedef struct str&#123; char *str; //串指针 int length; //串的长度 &#125;String; //赋值 int strAssign(String * s,char *p)&#123; //获取p的长度 int i=0; while(p[i]!='\0')&#123; i++; &#125; //给str分配内存，多分配一个空间存储'\0' s-&gt;str = (char *)malloc(sizeof(char) * (i+1)); //赋值 int j; for(j=0;j&lt;i;j++)&#123; s-&gt;str[j] = p[j]; &#125; s-&gt;str[j] = '\0'; s-&gt;length = i; return 1;&#125; 2.2 获取串的长度1234//获取串的长度int getLength(String *s)&#123; return s-&gt;length;&#125; 2.3 复制串&emsp;&emsp;先重新为str分配需要的内存，然后memset赋‘\0’。最后循环赋值。12345678910//复制串,将t复制到s中 void strCopy(String *s,String *t)&#123; s-&gt;str = (char*)malloc(sizeof(char) * (t-&gt;length+1)); memset(s-&gt;str,'\0',t-&gt;length+1); int i; for(i=0;i&lt;t-&gt;length;i++)&#123; s-&gt;str[i] = t-&gt;str[i]; &#125; s-&gt;length = t-&gt;length;&#125; 2.4 判断两个串是否相等12345678910111213//判断两个串是否相等int strEqual(String *s1,String *s2)&#123; char *ss1 = s1-&gt;str; char *ss2 = s2-&gt;str; if(s1-&gt;length != s2-&gt;length)&#123; return 0; &#125; if(*ss1++ != *ss2++)&#123; return 0; &#125; return 1;&#125; 2.5 连接两个串123456789101112131415161718192021222324//连接两个串int strConnect(String *s,String *p)&#123; int len = s-&gt;length + p-&gt;length; //临时空间 char *temp = (char*)malloc(sizeof(char) * (len+1)); int i,j; //拷贝s for(i=0;i&lt;s-&gt;length;i++)&#123; temp[i] = s-&gt;str[i]; &#125; //拷贝p for(j=0;j&lt;p-&gt;length;j++)&#123; temp[j+i] = p-&gt;str[j]; &#125; temp[j+i] = '\0'; //字符串指向temp s-&gt;str = temp; s-&gt;length = len; return 1;&#125; 2.6 比较两个串的大小1234567891011121314151617181920212223242526272829303132//比较两个串的大小 int strCompete(String *s,String *p)&#123; int slen = s-&gt;length; int plen = p-&gt;length; char *s1 = s-&gt;str; char *p1 = p-&gt;str; //同时遍历两个字符串，有一个为空时结束循环。 while(*s1!='\0' &amp;&amp; *p1!='\0')&#123; // s &gt; p if(*s1 &gt; *p1)&#123; return 1; &#125; //s &lt; p if(*s1 &lt; *p1)&#123; return -1; &#125; s1++; p1++; &#125; //两个字符串前n个字符相等时，比较长度 if(slen == plen)&#123; //s=p return 0; &#125; if(slen&gt;plen)&#123; //s&gt;p return 1; &#125; if(slen&lt;plen)&#123; //s&lt;p return -1; &#125;&#125; 2.7 插入串1234567891011121314151617181920212223242526272829//插入串 将字符串p插入到s的指定位置上 int strInsert(String *s,String *p,int pos)&#123; //位置判断 if(pos&lt;0||pos&gt;s-&gt;length)&#123; printf("insert position error!\n"); return; &#125; int len = s-&gt;length + p-&gt;length; char * temp = (char *)malloc(sizeof(char)*(len+1)); int i,j; //插入 s的左边部分 for(i=0;i&lt;pos;i++)&#123; temp[i] = s-&gt;str[i]; &#125; //插入 p for(j=0;j&lt;p-&gt;length;j++)&#123; temp[j+pos] = p-&gt;str[j]; &#125; //插入 s的右边部分 for(;i&lt;s-&gt;length;i++)&#123; temp[j+i] = s-&gt;str[i]; &#125; temp[j+i] = '\0'; s-&gt;str = temp; s-&gt;length = len;&#125; 2.8 删除指定串123456789101112131415161718192021222324252627//删除 int strDelete(String *s, int pos, int length)&#123; //位置判断 if(pos&lt;0||pos&gt;s-&gt;length)&#123; printf("delete position error!\n"); return; &#125; int len = s-&gt;length - length; char * temp = (char*)malloc(sizeof(char)*(len+1)); int i,j; for(i=0;i&lt;pos;i++)&#123; temp[i] = s-&gt;str[i]; &#125; j = pos+length; for(;j&lt;s-&gt;length;j++)&#123; temp[i] = s-&gt;str[j]; i++; &#125; temp[i] = '\0'; s-&gt;str = temp; s-&gt;length = len; return 1;&#125; 2.9 测试12345678910111213141516171819202122232425262728293031323334353637//串的顺序存储#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt; int main()&#123; printf("Create String:\n"); String * s = (String *)malloc(sizeof(String)); char *s1 = "abcdefg"; strAssign(s,s1); puts(s-&gt;str); printf("Length = %d\n",getLength(s)); printf("\n"); String * p = (String *)malloc(sizeof(String)); char *p1 = "abc"; strAssign(p,p1); printf("Copy String %s to %s:\n",s-&gt;str,p-&gt;str); strCopy(p,s); puts(s-&gt;str); printf("\n"); printf("是否相等：%d\n",strEqual(s,p)); printf("Insert String %s to %s:\n",p-&gt;str,s-&gt;str); strInsert(s,p,2); puts(s-&gt;str); printf("\n"); printf("Delete String:\n"); strDelete(s,2,3); puts(s-&gt;str); return 0;&#125; 输出结果： 3、串的链式存储&emsp;&emsp;串的链式存储可以使用单链表来存储字符，每一个结点存储1个字符(密度为1)，有利于串的插入或删除，但它的空间利用率太低。如果一个结点存储多个字符，对字符串的操作又会变得相当麻烦，得不偿失。串的链式存储的实用率很低，使用起来也不灵活，所以，一般都是使用串的顺序存储。 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(三)——队列]]></title>
    <url>%2F2019%2F01%2F20%2FDataStructure%2FdataStructure5%2F</url>
    <content type="text"><![CDATA[1、什么是队列&emsp;&emsp;队列是一个先进先出的线性表，它只允许在一端进行插入，在另一端进行删除操作。允许删除的称为队头，允许插入的称为队尾，分别由队头指针和队尾指针来维护队列。 &emsp;&emsp;队头指针指向第一个元素。当有元素出队（删除）时，队头指针向后移动一位，指向下一个元素。 &emsp;&emsp;队尾指针指向最后一个元素的之后的空指针，当有元素入队（插入）时，添加完元素后，队尾指针往后移动一位。&emsp;&emsp;如图所示： 2、顺序队列的实现&emsp;&emsp;使用顺序表实现的队列被称为顺序队列。它的实现和顺序表的实现比较相似，只是只能一端删除，一端插入。如图所示，是一个顺序队列图。 顺序队列的溢出： 真溢出：顺序表分配的空间已满，无法再入队。 假溢出：顺序表分配的空间未满，有出队元素，指针rear已经到达内存的最后一个空间(已经达到了最大下标)，无法再入队。 顺序队列的溢出可以用循环队列来解决，下面会讲到。 2.1 创建12345678910111213typedef struct Queue&#123; int front; //队头指针 int rear; //队尾指针 int data[MAXSIZE]; &#125;SeqQueue;//创建队列 SeqQueue* createSeqQueue()&#123; SeqQueue * queue = (SeqQueue*)malloc(sizeof(SeqQueue)); queue-&gt;front = queue-&gt;rear = -1; memset(queue-&gt;data,0,MAXSIZE*sizeof(int)); return queue;&#125; 2.2 判断是否为空1234567891011//判断是否为空 int isEmpty(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue"); return; &#125; if(queue-&gt;front == queue-&gt;rear)&#123; return 1; &#125; return 0;&#125; 2.3 获取长度1234567891011//获取长度 int getLength(SeqQueue * queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; return queue-&gt;rear - queue-&gt;front; &#125; return 0;&#125; 2.4 入队123456789101112131415161718192021//入队列int pushQueue(SeqQueue *queue,int data)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; //已满 if(queue-&gt;rear == MAXSIZE -1)&#123; printf("the queue already full ,not push!\n"); return; &#125; if(!isEmpty(queue))&#123; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear++; &#125;else&#123; queue-&gt;front = queue-&gt;rear = 0; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear++; &#125; return 1;&#125; 2.5 出队123456789101112131415//出队列int outQueue(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; int temp = queue-&gt;data[queue-&gt;front]; queue-&gt;front++; return temp; &#125;else&#123; printf("queue is null!"); return; &#125;&#125; 2.6 获取队头12345678910111213//获取队头 int getHead(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; return queue-&gt;data[queue-&gt;front]; &#125;else&#123; printf("queue is null!"); return; &#125;&#125; 2.7 其他123456789101112131415161718192021222324252627282930313233343536//清空队列int clearQueue(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; queue-&gt;front = queue-&gt;rear = -1; &#125; return 1;&#125; //销毁队列 int destoryQueue(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; free(queue); return 1;&#125; //打印void print(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; printf("队头-----------队尾\n"); int i; for(i=queue-&gt;front;i&lt;queue-&gt;rear;i++)&#123; printf("%d ",queue-&gt;data[i]); &#125; printf(" length = %d",getLength(queue)); printf("\n");&#125; 2.8 测试12345678910111213141516171819202122232425262728293031323334353637383940//顺序表实现队列#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;string.h&gt;#define MAXSIZE 1024 int main()&#123; printf("Create Seq Queue：\n"); SeqQueue * queue = createSeqQueue(); printf("%d\n\n",queue); printf("Push Seq Queue：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushQueue(queue,i); &#125; print(queue); printf("\n"); printf("Out Seq Queue：\n"); outQueue(queue); print(queue); printf("\n"); printf("Get Head from Queue：\n"); printf("%d\n",getHead(queue)); printf("\n"); printf("clear Queue：\n"); clearQueue(queue); print(queue); printf("Destory Queue：\n"); int flag = destoryQueue(queue); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果： 3、链式队列的实现&emsp;&emsp;用链表来实现的队列称为链式队列，它也是通过队头指针和队尾指针来操作结点。不用出现溢出问题。如图所示： 3.1 实现实现步骤同顺序队列，这里只给出实现代码和测试代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//链式队列 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Node; typedef struct queue&#123; Node * front; Node * rear; int length;&#125;LinkQueue;//创建队列 LinkQueue* createLinkQueue()&#123; LinkQueue * queue = (LinkQueue*)malloc(sizeof(LinkQueue)); queue-&gt;front = NULL; queue-&gt;rear = NULL; queue-&gt;length = 0; return queue;&#125;//判断是否为空 int isEmpty(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue"); return; &#125; if(queue-&gt;length==0 )&#123; return 1; &#125; return 0;&#125;//获取长度 int getLength(LinkQueue * queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; return queue-&gt;length; &#125; return 0;&#125;//入队列int pushQueue(LinkQueue *queue,int data)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; Node * newNode = (Node*)malloc(sizeof(Node)); newNode-&gt;data = data; if(!isEmpty(queue))&#123; queue-&gt;rear-&gt;next = newNode; queue-&gt;rear = newNode; queue-&gt;length++; &#125;else&#123; queue-&gt;front = newNode; queue-&gt;rear = newNode; queue-&gt;length++; &#125; return 1;&#125; //出队列Node * outQueue(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; Node * node = queue-&gt;front; queue-&gt;front = queue-&gt;front-&gt;next; queue-&gt;length--; return node; &#125;else&#123; printf("queue is null!"); return; &#125;&#125; //获取队头 Node * getHead(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; return queue-&gt;front; &#125;else&#123; printf("queue is null!"); return; &#125;&#125;//清空队列int clearQueue(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; queue-&gt;front = NULL; queue-&gt;rear = NULL; queue-&gt;length = 0; &#125; return 1;&#125; //销毁队列 int destoryQueue(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; free(queue); return 1; &#125; //打印void print(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; printf("队头-----------队尾\n"); int i; if(!isEmpty(queue))&#123; Node *curNode = queue-&gt;front; for(i=0;i&lt;queue-&gt;length;i++)&#123; printf("%d ",curNode-&gt;data); curNode = curNode-&gt;next; &#125; &#125; printf(" length = %d",getLength(queue)); printf("\n");&#125; 3.2 测试123456789101112131415161718192021222324252627282930313233int main()&#123; printf("Create Link Queue：\n"); LinkQueue * queue = createLinkQueue(); printf("%d\n\n",queue); printf("Push Link Queue：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushQueue(queue,i); &#125; print(queue); printf("\n"); printf("Out Link Queue：\n"); outQueue(queue); print(queue); printf("\n"); printf("Get Head from Link Queue：\n"); printf("%d\n",getHead(queue)-&gt;data); printf("\n"); printf("clear Queue：\n"); clearQueue(queue); print(queue); printf("Destory Queue：\n"); int flag = destoryQueue(queue); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果： 4、循环队列的实现&emsp;&emsp;为了解决顺序队列的假溢出问题，充分利用数组的空间，可以将队列首尾相连，构成一个循环队列。如图所示： 注意点: front==rear时会出现两种情况，队列空和队列满，所以规定最后一个位置不存储数据，当rear在front前一个位置，判断队列已满。 判断空： front==rear 判断已满： (rear+1) % MAXSIZE == front 求队列长度：(rear + MAXSIZE - front) % MAXSIZE 因为rear可能会出现在front前面，导致它们相减可能为负。 由于循环队列其他操作与顺序队列基本一致，故不再贴出相同的代码，如需要完整代码，点击这里。 4.1 部分代码:123456789101112131415161718192021222324252627282930313233343536373839//入队列int pushQueue(CircleQueue *queue,int data)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; //已满 int rear = queue-&gt;rear; int front = queue-&gt;front; if((rear+1) % MAXSIZE == front)&#123; printf("the queue already full ,not push!\n"); return; &#125; if(!isEmpty(queue))&#123; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear = (queue-&gt;rear+1) % MAXSIZE; &#125;else&#123; queue-&gt;front = queue-&gt;rear = 0; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear++; &#125; return 1;&#125; //出队列int outQueue(CircleQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; int temp = queue-&gt;data[queue-&gt;front]; queue-&gt;front = (queue-&gt;front+1) % MAXSIZE; return temp; &#125;else&#123; printf("queue is null!"); return; &#125;&#125; 4.2 测试:123456789101112131415161718192021222324252627282930313233int main()&#123; printf("Create Circle Queue：\n"); CircleQueue * queue = createCircleQueue(); printf("%d\n\n",queue); printf("Push Circle Queue：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushQueue(queue,i); &#125; print(queue); printf("\n"); printf("Out Circle Queue：\n"); outQueue(queue); print(queue); printf("\n"); printf("Get Head from Queue：\n"); printf("%d\n",getHead(queue)); printf("\n"); printf("clear Queue：\n"); clearQueue(queue); print(queue); printf("Destory Queue：\n"); int flag = destoryQueue(queue); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果： 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(三)——栈]]></title>
    <url>%2F2019%2F01%2F19%2FDataStructure%2FdataStructure4%2F</url>
    <content type="text"><![CDATA[1、什么是栈&emsp;&emsp;栈是一个先进后出的线性表，仅允许在栈的一端进行插入和删除操作。栈中允许插入删除的一端叫做栈顶，另一端叫做栈底。元素的删除叫做出栈，元素的插入叫做入栈。栈满时不能入栈，栈空时不能出栈。 &emsp;&emsp;栈通过一个栈顶指针来执行各种操作，入栈时栈顶指针上移，出栈时栈顶指针下移。如图所示：&emsp;&emsp;栈的常见操作： 创建栈 判断是否是空 出栈 入栈 获取栈顶元素 销毁栈 2、栈的实现2.1 顺序表实现2.1.1 创建栈12345678910typedef struct stack&#123; int data[MAXSIZE]; int top; //栈顶指针 &#125;SeqStack;//创建栈 SeqStack * createSeqStack()&#123; SeqStack *stack = (SeqStack *)malloc(sizeof(SeqStack)); stack-&gt;top = -1;&#125; 2.1.2 判断是否是空1234567891011//判断空int isEmpty(SeqStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(stack-&gt;top == -1)&#123; return 1; &#125; return 0;&#125; 2.1.3 入栈123456789101112131415//入栈 int pushStack(SeqStack *stack,int data)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; //判断是否栈满 if(stack-&gt;top == MAXSIZE-1)&#123; printf("stacl already full!\n"); return -3; &#125; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = data; return 1;&#125; 2.1.4 出栈123456789101112//出栈 int popStack(SeqStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; return stack-&gt;data[stack-&gt;top--]; &#125; return -2;&#125; 2.1.5 获取栈顶元素12345678910111213//获取栈顶元素int getTopStack(SeqStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; return stack-&gt;data[stack-&gt;top]; &#125; return -2;&#125; 2.1.6 销毁栈1234567891011//销毁栈int destoryStack(SeqStack *stack) &#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; free(stack); &#125; return 1;&#125; 2.1.7 打印123456789101112//打印void print(SeqStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return; &#125; int i; for(i=0;i&lt;=stack-&gt;top;i++)&#123; printf("%d ",stack-&gt;data[i]); &#125; printf("\n");&#125; 2.1.8 测试12345678910111213141516171819202122232425262728293031323334//顺序表实现栈 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define MAXSIZE 1024int main()&#123; printf("Create Stack：\n"); SeqStack * stack = createSeqStack(); printf("%d\n\n",stack); printf("Push Stack：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushStack(stack,i); &#125; print(stack); printf("\n"); printf("Pop Stack：\n"); popStack(stack); print(stack); printf("\n"); printf("Get top from stack：\n"); printf("%d\n",getTopStack(stack)); printf("\n"); printf("Destory stack：\n"); int flag = destoryStack(stack); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果: 2.2 单链表实现&emsp;&emsp;栈的链式存储称为链栈，它和链表的存储方式一样，都可以使用内存中的闲余空间，它用指针来构建结点之间的关系。链栈需要设置一个栈顶指针Top，指向栈顶。链栈是一个单向操作的链表，只能从一端进行操作。 &emsp;&emsp;如图所示： 2.1.1 创建栈123456789101112131415161718typedef struct node&#123; int data; struct node *next;&#125;Node;typedef struct stack&#123; int size; //栈大小 struct node *top; //栈顶指针 &#125;LinkStack;LinkStack * createLinkStack()&#123; LinkStack *stack = (LinkStack *)malloc(sizeof(LinkStack)); if(stack!=NULL)&#123; stack-&gt;top = NULL; stack-&gt;size = 0; &#125; return stack; &#125; 2.1.2 判断是否是空123456789101112//判断空int isEmpty(LinkStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(stack-&gt;top == NULL || stack-&gt;size &lt;=0)&#123; return 1; &#125; return 0;&#125; 2.1.3 入栈1234567891011121314151617181920//入栈 int pushStack(LinkStack *stack,int data)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; Node * node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; if(!isEmpty(stack))&#123; //不是空 node-&gt;next = stack-&gt;top; stack-&gt;top = node; &#125;else&#123; //是空 stack-&gt;top = node; &#125; stack-&gt;size++; return 1;&#125; 2.1.4 出栈123456789101112131415//出栈 Node * popStack(LinkStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; Node * topNode = stack-&gt;top; stack-&gt;top = stack-&gt;top-&gt;next; stack-&gt;size--; return topNode; &#125; return -2;&#125; 2.1.5 获取栈顶元素12345678910111213//获取栈顶元素Node* getTopStack(LinkStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; return stack-&gt;top; &#125; return -2;&#125; 2.1.6 打印123456789101112131415161718//打印void print(LinkStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return; &#125; int i; Node * curNode = stack-&gt;top; //curNode指向栈底 printf("栈顶&lt;----------栈底\n"); for(i=0;i&lt;stack-&gt;size;i++)&#123; printf("%d ",curNode-&gt;data); curNode = curNode-&gt;next; &#125; printf("\n");&#125; 2.1.7 测试123456789101112131415161718192021222324252627282930313233//单链表实现栈 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; printf("Create Link Stack：\n"); LinkStack * stack = createLinkStack(); printf("%d\n\n",stack); printf("Push Link Stack：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushStack(stack,i); &#125; print(stack); printf("\n"); printf("Pop Stack：\n"); popStack(stack); print(stack); printf("\n"); printf("Get top from stack：\n"); printf("%d\n",getTopStack(stack)-&gt;data); printf("\n"); printf("Destory stack：\n"); int flag = destoryStack(stack); print(stack); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果： 3、栈的应用3.1 用栈实现四则运算3.2 栈的递归调用 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(二)——线性表2]]></title>
    <url>%2F2019%2F01%2F18%2FDataStructure%2FdataStructure3%2F</url>
    <content type="text"><![CDATA[作者个人博客 https://www.you3xuan.top/ 查看原文。 1、线性表的链式存储&emsp;&emsp;在链式存储中，结点之间的内存单元地址是不连续的。它的每一个结点包括数据域和下一个结点的地址。头结点的数据域只存放结点的长度，并指向第一个元素。尾结点指向NULL。如图所示： &emsp;&emsp;因为内存单元不连续，所以哪里空闲的内存，都可以分配一个结点，提高了内存的利用率。又因为结点之间只通过地址连接，所以删除和插入结点效率高。又因为没有索引与结点对应，查找一个结点的时候，必须找到上一个结点，所以查询效率不高。 2、链式存储的实现2.1 创建单链表&emsp;&emsp;分为三部分，创建头结点，创建普通结点，创建单链表。 创建头结点 12345//创建头结点，length存储链表的长度 next指向下一个结点 typedef struct Header&#123; int length; struct Header * next;&#125;Head; 创建普通结点 12345//创建一个结点，data存放数据，next指向下一个结点 typedef struct Node&#123; int data; struct Node *next; &#125;ListNode; 创建链表 1234567//创建一个链表，返回头结点 Head * createList()&#123; Head *phead = (Head*)malloc(sizeof(Head)); phead-&gt;length = 0; phead-&gt;next = NULL; return phead;&#125; 2.2 获取链表长度12345678// 获取链表长度int getLength(Head * phead)&#123; if(phead==NULL)&#123; printf(&quot;not init headnode!\n&quot;); return -1; &#125; return phead-&gt;length;&#125; 2.3 添加结点1234567891011121314151617181920212223// 添加数据，,默认添加在末尾 int addData(Head * phead, int data)&#123; if(phead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; //创建当前结点，并指向链表最后一个结点 ListNode * curNode = phead; while(curNode-&gt;next!=NULL)&#123; curNode = curNode-&gt;next; &#125; //创建新结点 ListNode * newNode = (ListNode*)malloc(sizeof(ListNode)); newNode-&gt;data = data; newNode-&gt;next = NULL; //连接结点 curNode-&gt;next = newNode; phead-&gt;length++; return 1; &#125; &emsp;&emsp;如图所示，添加结点需要两个结点，一个当前结点，指向尾结点，另一个是要添加的新结点，指向NULL,使用当前结点的next指向新结点，就完成了添加结点的操作。因为当前结点是指向尾结点的，当前结点的next就相当于尾结点的next，所有就相当于尾结点的next指向了新结点。最后别忘把头结点的length加1。 2.4 插入结点12345678910111213141516171819202122232425262728// 插入数据 int insertData(Head * pHead, int data, int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt; pHead-&gt;length)&#123; printf("insert postion error!\n"); return -2; &#125; //创建新结点 ListNode * newNode = (ListNode *)malloc(sizeof(ListNode)); newNode-&gt;data = data; //创建当前结点 ListNode * curNode = pHead; int i; for(i=0;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; newNode-&gt;next = curNode-&gt;next; curNode-&gt;next = newNode; pHead-&gt;length++; return 1; &#125; &emsp;&emsp;同样，插入也需要两个结点，一个结点指向要插入的位置的前一个结点，起名为当前结点。另一个为新结点。主要就是两行代码：12newNode-&gt;next = curNode-&gt;next;curNode-&gt;next = newNode; &emsp;&emsp;当前结点指向待插入位置的前一个结点，起名为前结点(lastNode)。以上代码相当于：12newNode-&gt;next = lastNode-&gt;next;lastNode-&gt;next = newNode; &emsp;&emsp;因为lastNode-&gt;next指向下一个结点。现在使用newNode-&gt;next指向下一个结点。然后使用lastNode-&gt;next指向newNode。就完成了插入操作。&emsp;&emsp;两行代码不可颠倒位置，因为先执行第二行代码的话，会导致后面结点全部丢失。 2.5 删除结点1234567891011121314151617181920212223// 删除数据 int deleteData(Head * pHead,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt;= pHead-&gt;length)&#123; printf("delete postion error!\n"); return -2; &#125; //创建当前结点 ListNode * curNode = pHead; int i; for(i=0;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; curNode-&gt;next = curNode-&gt;next-&gt;next; pHead-&gt;length--; return 1;&#125; &emsp;&emsp;当前结点指定要删除位置的上一个结点(前结点)，把前结点的next指向下一个结点的next,curNode-&gt;next = curNode-&gt;next-&gt;next,就完成了删除操作。 2.6 获取指定位置的结点12345678910111213141516171819//获取数据 int getData(Head * pHead,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt;= pHead-&gt;length)&#123; printf("postion error!\n"); return -2; &#125; //创建当前结点 ListNode * curNode = pHead; int i; for(i=0;i&lt;=pos;i++)&#123; curNode = curNode-&gt;next; &#125; return curNode-&gt;data;&#125; 2.7 打印所有结点1234567891011121314//打印 void print(Head * phead)&#123; if(phead==NULL)&#123; printf("not init headnode!\n"); return 0; &#125; ListNode * node = phead-&gt;next; while(node-&gt;next!=NULL)&#123; printf("%d-&gt;",node-&gt;data); node = node-&gt;next; &#125; printf("%d length=%d\n",node-&gt;data,phead-&gt;length);&#125; &emsp;&emsp;为了让打印效果更好，想法去掉了最后一个-&gt;，并且输出链表的长度。 2.8 测试1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i; printf("create ListNode:\n"); Head* pHead = createList(); printf("length=%d\n\n",pHead-&gt;length); printf("add data:\n"); for(i=0;i&lt;10;i++)&#123; addData(pHead,i); &#125; print(pHead) ; printf("\n"); printf("insert data:\n"); insertData(pHead,100,3); print(pHead); printf("\n"); printf("delete data:\n"); deleteData(pHead,3); print(pHead); printf("\n"); printf("get data:\n"); printf("%d\n",getData(pHead,5)); printf("\n"); return 0;&#125; 输出结果： 3、双链表实现链式存储定义&emsp;&emsp;前面使用单链表实现了线性表的链式存储。但是单链表有个缺点，无法访问前驱结点。当查找到一个元素结点时，如果想要找到前面的元素结点，需要从头开始遍历，比较麻烦。所有双链表有开辟了一个空间,存储结点前驱结点的地址。如图所示： &emsp;&emsp;双链表的实现和单链表类似，当我们插入一个新结点时，如果这个结点有后驱结点时，要是后驱结点的pre 指向新结点，新结点的pre也要指向它的前驱结点。其他操作类似，这里只贴出代码，就不详细解释了。 3.1 创建双链表12345678910111213141516171819202122typedef struct Header&#123; int length; struct Header * pre; //为了方便，在头结点添加一个pre ，不然无法指向 Node,在Head后面添加结点时就需要单独判断。 struct Header * next;&#125;Head;typedef struct Node&#123; int data; struct Node * pre; struct Node * next;&#125;NodeList;//创建 Head * createDouNodeList()&#123; Head * pHead = (Head*)malloc(sizeof(Head)); if(pHead == NULL)&#123; printf("create failure!\n"); &#125; pHead-&gt;length = 0; pHead-&gt;next = NULL; return pHead;&#125; 3.2 获取链表长度12345678// 获取链表长度int getLength(Head * pHead)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; return pHead-&gt;length;&#125; 3.3 判断是否为空123456789101112//判断是否为空int isEmpty(Head *pHead)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pHead-&gt;length==0)&#123; return 1; &#125;else&#123; return 0; &#125;&#125; 3.4 添加结点1234567891011121314151617181920212223// 添加结点，,默认添加在末尾 int addDataDou(Head * pHead, int data)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; //创建当前结点，并指向链表最后一个结点 NodeList * curNode = pHead; while(curNode-&gt;next != NULL)&#123; curNode = curNode-&gt;next; &#125; //创建新结点 NodeList * newNode = (NodeList*)malloc(sizeof(NodeList)); newNode-&gt;data = data; newNode-&gt;next = NULL; curNode-&gt;next = newNode; newNode-&gt;pre = curNode; pHead-&gt;length++; return 1;&#125; 3.5 插入结点1234567891011121314151617181920212223242526272829303132//插入 int insertDou(Head *pHead,int data,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos&lt;=0||pos&gt;=pHead-&gt;length)&#123; printf("insert positon error!\n"); return -2; &#125; //创建新结点 NodeList * newNode = (NodeList*)malloc(sizeof(NodeList)); newNode-&gt;data = data; //创建当前结点,并指向 指定位置之前的那个结点 NodeList * curNode = pHead; int i; for(i=0;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; //连接 newNode-&gt;next = curNode-&gt;next; curNode-&gt;next-&gt;pre = newNode; newNode-&gt;pre = curNode; curNode-&gt;next = newNode; pHead-&gt;length++; return 1;&#125; 3.6 删除结点1234567891011121314151617181920212223242526272829//删除 int deleteDataDou(Head * pHead,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt;= pHead-&gt;length)&#123; printf("delete postion error!\n"); return -2; &#125; //创建当前结点 NodeList * curNode = pHead; int i; for(i=0;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; curNode-&gt;next = curNode-&gt;next-&gt;next; //要删除最后一个结点时判断 if(curNode-&gt;next!=NULL)&#123; curNode-&gt;next-&gt;pre = curNode; &#125; pHead-&gt;length--; return 1;&#125; 3.7 获取指定元素的结点12345678910111213141516//查找某个元素，返回它的结点 NodeList * findNodeDou(Head *pHead,int val)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return 0; &#125; NodeList *curNode = pHead-&gt;next; do&#123; if(curNode-&gt;data == val)&#123; return curNode; &#125; curNode = curNode-&gt;next; &#125;while(curNode-&gt;next!=NULL); return NULL;&#125; 3.8 打印所有结点12345678910111213//打印 void print(Head * pHead)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return 0; &#125; NodeList * node = pHead-&gt;next; while(node-&gt;next!=NULL)&#123; printf("%d&lt;-&gt;",node-&gt;data); node = node-&gt;next; &#125; printf("%d length=%d\n",node-&gt;data,pHead-&gt;length);&#125; 3.9 测试123456789101112131415161718192021222324252627282930313233343536//双链表实现链式存储 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main()&#123; int i; printf("Create Double Node List: \n"); Head *pHead = createDouNodeList(); printf("length = %d\n",pHead-&gt;length); printf("\n"); printf("Add Data: \n"); for(i=0;i&lt;10;i++)&#123; addDataDou(pHead,i); &#125; print(pHead); printf("\n"); printf("Insert Data: \n"); insertDou(pHead,100,3); print(pHead); printf("\n"); printf("delete Data: \n"); deleteDataDou(pHead,3); print(pHead); printf("\n"); printf("find Node: \n"); NodeList * node = findNodeDou(pHead,3); printf("node is %d\n",node); printf("\n"); return 0;&#125; 输出结果： 4、循环链表&emsp;&emsp;链表还有一种常用的形式，那就是循环链表。循环链表首尾相接，形成一个环，从链表任何一个结点出发，都能够找到其他所有结点。 &emsp;&emsp;循环链表分为单向循环链表，双循环链表，多重循环链表。如图所示： &emsp;&emsp;上图是单向循环链表，形成一个闭合环，有一个方向。&emsp;&emsp;上图是双向循环链表，形成一个闭合环，有两个方向。&emsp;&emsp;上图是多重循环链表，形成了两个闭合环。 &emsp;&emsp;本教程只讲解单向循环链表，其他两种比较复杂，如需要的话，自行搜索。 循环链表的创建和查找基本和单链表一样，这里就不过多讲解了，只讲解插入和删除。如果您还不太清楚，请认真阅读前面的知识。 4.1 插入结点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int insertCircleList(Head * pHead,int data,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt; pHead-&gt;length)&#123; printf("insert postion error!\n"); return -2; &#125; //创建新结点 NodeList * newNode = (NodeList*)malloc(sizeof(NodeList)); newNode-&gt;data = data; //如果是空 if(isEmpty(pHead))&#123; pHead-&gt;next = newNode; //直接插入到头结点后面 newNode-&gt;next = newNode; //自己指向自己 &#125;else&#123; NodeList *curNode = pHead-&gt;next; //因为pos ==0为涉及到头结点，单独处理 if(pos==0)&#123; //curNode指向尾结点 while(curNode-&gt;next!=pHead-&gt;next)&#123; curNode = curNode-&gt;next; &#125; newNode-&gt;next =pHead-&gt;next; pHead-&gt;next = newNode; curNode-&gt;next = newNode; &#125;else&#123; //使curNode指向插入位置的前一个结点 int i; for(i=1;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; newNode-&gt;next = curNode-&gt;next; curNode-&gt;next = newNode; &#125; &#125; pHead-&gt;length++; return 1;&#125; 4.2 删除结点12345678910111213141516171819202122232425262728293031323334int deleteCircleNode(Head *pHead,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt; pHead-&gt;length)&#123; printf("insert postion error!\n"); return -2; &#125; NodeList *curNode = pHead-&gt;next; if(isEmpty(pHead))&#123; return -3; &#125;else&#123; if(pos==0)&#123; while(curNode-&gt;next!=pHead-&gt;next)&#123; curNode = curNode-&gt;next; &#125; curNode-&gt;next = curNode -&gt;next-&gt;next; pHead-&gt;next = curNode -&gt;next; &#125;else&#123; int i; for(i=1;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; curNode -&gt;next = curNode-&gt;next-&gt;next; &#125; &#125; pHead-&gt;length--; return 1; &#125; 4.3 其他代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//创建头结点，length存储链表的长度 next指向下一个结点 typedef struct Header&#123; int length; struct Header * next;&#125;Head;//创建一个结点，data存放数据，next指向下一个结点 typedef struct Node&#123; int data; struct Node *next; &#125;NodeList;//创建一个链表，返回头结点 Head * createList()&#123; Head *phead = (Head*)malloc(sizeof(Head)); phead-&gt;length = 0; phead-&gt;next = NULL; return phead;&#125;//判断是否为空int isEmpty(Head *pHead)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pHead-&gt;length==0)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;//打印 void print(Head *pHead)&#123; if(pHead==NULL)&#123; printf("not init headnode!\n"); return 0; &#125; NodeList * node = pHead-&gt;next; do&#123; printf("%d-&gt;",node-&gt;data); node = node-&gt;next; &#125;while(node!=pHead-&gt;next); printf(" length=%d\n",pHead-&gt;length);&#125; 4.4 测试12345678910111213141516171819202122//循环链表#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i; printf("Create Circle Node List: \n"); Head * pHead = createList(); printf("length = %d\n",pHead-&gt;length); printf("\n"); printf("Insert Node: \n"); for(i=0;i&lt;11;i++)&#123; insertCircleList(pHead,i,i); &#125; print(pHead); printf("\n"); printf("Delete Node: \n"); deleteCircleNode(pHead,0); print(pHead); return 0;&#125; 输出结果： 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(二)——线性表1]]></title>
    <url>%2F2019%2F01%2F17%2FDataStructure%2FdataStructure2%2F</url>
    <content type="text"><![CDATA[1、线性表的定义和特征1.1 定义&emsp;&emsp;线性表是具有相同类型元素组成的一个线性序列。元素的个数即为元素的长度，元素为0时称为空表。如下： (A,B,C,D,E,F,G)&emsp;&emsp;这就表示一个线性表。 1.2 特征 有且只有一个头结点，头结点没有前驱结点。 有且只有一个尾结点, 尾结点没有后继节点。 除头尾结点外，其他结点都有一个前驱结点和后继节点。 1.3 存储特征&emsp;&emsp;线性表的存储结构分为顺序存储和链式存储，它们都具有如下特点： 唯一性：一个线性表只能存储一种类型的元素 有序性：各元素在线性表中的位置只取决于它的序号，数据元素之间的相对位置为线性的（并不是内存结构上的有序）。 1.4 基本操作 创建 create() 初始化 init() 添加数据 addData() 获取长度 getLength() 获取指定元素 get() 插入 insert() 删除 delete() 清空表 clear() 这8种只是线性表的最基本操作，如果想要进阶，请自己谷歌。 2、线性表的顺序存储&emsp;&emsp;数据被存储在指定长度的连续存储单元，通过对应的索引(一般从0开始)找到对应的元素。在高级语言中，顺序存储可以用数组表示。 &emsp;&emsp;前面提到过线性表的顺序存储查询效率高，插入和删除效率低。适合存储需要连续存取的数据。 2.1 顺序存储的实现2.1.1 创建顺序表并初始化&emsp;&emsp;使用结构体创建一个结点，这个结点存储了这个顺序表的基本信息，包括capacity,length,node。为了简单起见，只存储整形数据，其中用到了malloc和memset函数 ，代码如下： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//创建结点typedef struct SeqList &#123; //包含表的各种属性 int capacity; // 容量 int length; //长度 int * node; //指针数组&#125; HSeqList; 123456789101112131415161718192021222324//创建顺序表HSeqList * createSeqList(int capacity) &#123; int ret; HSeqList * head = (HSeqList *)malloc(sizeof(HSeqList)); if(head == NULL) &#123; ret = 1; printf("create seqList error %d\n",ret); return NULL; &#125; memset(head,0,sizeof(HSeqList)); //清空头结点 head-&gt;capacity = capacity; head-&gt;length = 0; head-&gt;node = (int *) malloc(sizeof(void *)*capacity); if(head-&gt;node == NULL) &#123; ret = 2; printf("create seqList error %d\n",ret); return NULL; &#125; return head;&#125; 2.1.2 获取长度，容量并且封装打印方法。123456789101112131415161718192021222324252627282930313233//求顺序表容量int getCapacity(HSeqList * list) &#123; HSeqList * temp = NULL; if(list == NULL) &#123; return; &#125; temp = list; return temp-&gt;capacity;&#125;//求顺序表长度int getLength(HSeqList * list) &#123; HSeqList * temp = NULL; if(list == NULL) &#123; return; &#125; temp = list; return temp-&gt;length;&#125;//输出void print(HSeqList * list)&#123; if(list == NULL) &#123; printf("not init SeqList\n"); return; &#125; int length = getLength(list); int i; printf("["); for(i=0;i&lt;length-1;i++)&#123; printf("%d,",list-&gt;node[i]); &#125; printf("%d]\n",list-&gt;node[i]);&#125; 2.1.3 添加数据123456789101112131415//添加数据int addData(HSeqList * list,int data) &#123; if(list == NULL)&#123; printf("not init SeqList\n"); return 0; &#125; if(list-&gt;length&gt;=list-&gt;capacity)&#123; printf("SeqList is full,not add data,current data is %d\n",data); return 0; &#125; int index = list-&gt;length; list-&gt;node[index] = data; list-&gt;length++; return 1;&#125; 2.1.4 插入&emsp;&emsp;如果要在顺序表中插入数据，则需要将该位置后的所有元素往后移动。例如，在[A,B,C,D,E,F]中把G插入到第二个位置。要先移位然后插入。如图所示： 代码如下：123456789101112131415161718192021222324252627//插入int insert(HSeqList *list,int data,int pos)&#123; int i; if(list == NULL) &#123; printf("not init SeqList\n"); return -1; &#125; if(list-&gt;length&gt;=list-&gt;capacity)&#123; printf("SeqList is full,not insert data,current data is %d\n",data); return -2; &#125; //如何插入位置在length之前，则默认插入到最后一位 if(pos&gt;list-&gt;length)&#123; pos = list-&gt;length; &#125; //从后往前移位，防止数据丢失 for(i=list-&gt;length;i&gt;pos;i--)&#123; list-&gt;node[i] = list-&gt;node[i-1]; &#125; //插入数据 list-&gt;node[i] = data; //增加长度 list-&gt;length ++; return 1;&#125; 2.1.5 删除&emsp;&emsp;删除指定位置的元素后，该位置往后的元素依次往前移动。1234567891011121314151617181920212223 delete(HSeqList *list, int pos) &#123; if(list == NULL) &#123; printf("not init SeqList!\n"); return -1; &#125; if(list-&gt;length &lt;= 0) &#123; printf("SeqList not data!\n"); return -2; &#125; if(pos &lt; 0 || pos &gt;list-&gt;length)&#123; printf("delete position error!\n"); return -3; &#125; int i; for(i=pos; i&lt;=list-&gt;length;i++)&#123; list-&gt;node[i] = list-&gt;node[i+1]; &#125; list-&gt;length--; return 1;&#125; 2.1.6 查找某个位置上的指定元素 12345678910111213//查找某个位置上的指定元素int getData(HSeqList *list,int pos)&#123; if(list == NULL) &#123; printf("not init SeqList!\n"); return -1; &#125; if(pos &lt; 0 || pos &gt;=list-&gt;length)&#123; printf("position error!\n"); return -3; &#125; return list-&gt;node[pos];&#125; 2.1.7 清空表12345678910//清空表int clear(HSeqList *list)&#123; if(list == NULL) &#123; printf("not init SeqList!\n"); return -1; &#125; list-&gt;length = 0; memset(list-&gt;node,0,(list-&gt;capacity * sizeof(void *))); return 1;&#125; 2.1.8 测试代码123456789101112131415161718192021222324252627282930int main() &#123; printf("init:\n"); int capacity = 100; HSeqList *list = createSeqList(capacity); int s = getCapacity(list); printf("Capacity = %d\n",s); printf("addData:\n"); int i; for(i=0; i&lt;10; i++) &#123; addData(list,i); &#125; print(list); printf("insert:\n"); insert(list,100,3); print(list); printf("delete:\n"); delete(list,3); print(list); printf("getData:\n"); printf("index %d is %d\n",0,getData(list,0)); printf("clear:\n"); clear(list); print(list); return 0;&#125; 输出结果： 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(一)—— 概述]]></title>
    <url>%2F2019%2F01%2F16%2FDataStructure%2FdataStructure1%2F</url>
    <content type="text"><![CDATA[1、为什么要学习数据结构？&emsp; &emsp;数据结构是是计算机专业最重要的基础之一，它是大学计算机专业的必修课，也是程序员提高自己的重要知识结构。对于学生而言，它对你以后考研和面试都用很重要的帮助。对于程序员而言，它能拓宽人的学习深度，决定了你日后能到达怎样的高度，更能体现人的学习素养，对日后的工作面试有很大的用途。 &emsp; &emsp;本教程主要介绍数据结构的常见用法，为了兼容更多人群，所有以C语言为主要的编程语言。如果您C语言基础不过关，请自行Google。其次，语言只是描述程序的一种形式，万变不离其中，掌握一种也就很容易掌握另外一种。 2、什么是数据结构？维基百科给出了定义: 数据结构（英语：data structure）是计算机中存储、组织数据的方式。无论是大数据时代的海量数据的存储，还是简单用户信息或者学生信息的存储，其数据存储的底层都要以某种更方便、更快捷且更省内存空间的方式进行，这种存储方式就是数据结构。如下图，就是一个简单的数据结构，他描述一个基础的学生信息，由id,name,sex,class组成。 id name sex class 001 张三 男 1班 002 李四 男 2班 003 王五 男 3班 2.1、基本术语 数据 &emsp; &emsp;计算机中存储的的最小单位 数据元素 &emsp; &emsp; 也叫元素或记录，及为上表中的一行。 数据对象 &emsp; &emsp; 数据元素的集合 3、数据结构的分类3.1、逻辑结构 描述元素之间的逻辑关系，与数据的存储位置无关。他包括集合、线性结构，树形结构和图形结构。 1、集合&emsp; &emsp; 类似于数学中的集合，一个数据存在于集合中，数据之间没有什么关系。 2、线性结构&emsp; &emsp; 与元素具有一对一的关系，在内存中逐个排列。它分为顺序存储和链式存储，顺序存储相当于高级语言的数组，在内存中排列是连续的。链式存储使用链表维护元素，在内存中排列是不连续的。 3、树形结构&emsp; &emsp; 使用树来维护元素的多个层次关系（对二叉树不了解请点击链接），除根结点外，一个节点只有一个父结点，可以根据一个节点寻找它的子结点或者父结点。 4、图形结构&emsp;&emsp;使用图)来维护元素的多个层次关系（图不了解请点击链接），一个图中的结点可以有多个父结点和子结点。 3.2、存储结构1、顺序存储结构&emsp;&emsp;使用顺序表来存储数据，数据存储在是连续的内存单元上。 优点：查询效率高，可以使用元素的下标直接找到某一个元素。因为其存储结构是紧密的，所以提高了空间利用率。 缺点：插入和删除一个元素的效率低，插入或者删除一个元素，要把这个元素的右边所有元素右移或者左移1个单位，随着数据量的增大，插入和删除的效率也会随之下降。且存储空间大小在定义时已经明确指定，操作元素是会出现“溢出”或者浪费空间的情况。 2、链式存储结构&emsp;&emsp;使用链表来存储数据，数据存储在是不连续的内存单元上。 优点：插入和删除效率很高，不会造成空间的浪费。 缺点：无法随机访问，内存单元一部分用来存储元素之间的逻辑关系，造成空间利用率低。 3、索引存储结构&emsp;&emsp;除建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引表由若干索引项组成 &emsp;&emsp;特点：索引存储结构是用结点的索引号来确定结点存储地址，其优点是检索速度快，缺点是增加了附加的索引表,会占用较多的存储空间。 4、散列存储结构&emsp;&emsp;散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。 &emsp;&emsp;散列法存储的基本思想是：由节点的关键码值决定节点的存储地址。散列技术除了可以用于查找外，还可以用于存储。 &emsp;&emsp;特点：散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的。 4、算法程序 = 数据结构 + 算法 算法是数据结构的灵魂，一个数据结构设计的再好，如果没有算法，如同失去了灵魂，它的存在就毫无意义。 4.1 什么是算法&emsp;&emsp;算法是解决某个特定问题的具体步骤。 &emsp;&emsp;描述算法的方法：伪代码法，N-S结构化流程图和流程图， 具体方法请自行百度。 4.2 算法的特性 确定性 可行性 有穷性 零个或者多个输入 一个或者多个输出 正确性 可读性 健壮性 高效率和低存储 4.3 算法的复杂度&emsp;&emsp;用来表示算法执行消耗的计算机资源，主要从时间和空间两个方面考虑。 1、时间复杂度&emsp;&emsp;描述算法的执行时间(次数)，常用O(n)表示。推导方法: n为常数，用1代替。 n为未知数，系数为1，只保留最高阶项。 n为未知数，系数不为1，只保留最高阶项且最高阶项除去系数。 例子如下：123int a = 1;int b = 2;int sum = a + b; 共执行$f（n）= 3$ 次，所以 时间复杂度为O(1)。 1234567void fun()&#123; int i,sum; //执行一次 for(i=0;i&lt;n;i++)&#123; sum += i; //执行n次 &#125; printf("%d\n",sum); //执行一次&#125; 共执行f（n）= n+3次，所以 时间复杂度为O(n)。 123456void fun()&#123; int i = 1; while(i &lt; n)&#123; i * = 2; &#125;&#125; 共执行$ 2^f = n $, 即 $ f = {log_2{n}}$，所以复杂度为O(logn)。 2、空间复杂度&emsp;&emsp;算法运行所占空间的大小，常用O(n)表示。 4、算法和数据结构&emsp;&emsp;算法通常是决定程序效率的关键，但是一切算法最终都要在相应的数据结构上实现，许多算法的精髓就是在于选择了合适的数据结构作为基础。在程序设计中，不但要注重算法设计，也要正确选择数据结构，这样往往能够事半功倍。 具体参考如下:LeetCode1 使用散列存储，极大的提高了算法效率。 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6(ZigZag Conversion)]]></title>
    <url>%2F2018%2F12%2F16%2FLeetCode%2Fleetcode6%2F</url>
    <content type="text"><![CDATA[ZigZag Conversion（ZigZag转换）1、题目描述：The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P &emsp;&emsp; &emsp;A &emsp;&emsp;&emsp;H &emsp; &emsp; &emsp;NA &emsp;P &emsp; L&emsp; S&emsp; I&emsp; &emsp;I &emsp; GY &emsp;&emsp;&emsp; I &emsp;&emsp;&emsp; RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows);Example 1: Input: s = “PAYPALISHIRING”, numRows = 3Output: “PAHNAPLSIIGYIR” &emsp; &emsp;给出一个指定字符串和numRows，把字符串按倒Z的形式排列，行数为numRows，按行排列返回字符串。 2、解决方法1：按行分类(Java实现)&emsp; &emsp;仔细观察这个Z型的图形，它是由nomRows行子串构成。所以可以遍历整个字符串把字符依次添加到指定行字符串上，方向为先下后上。 123456789101112131415161718192021222324252627282930313233343536373839public String convert(String s, int numRows) &#123; //numRows为1，直接返回s if (numRows==1)&#123; return s; &#125; //构建Math.min(numRows, s.length())个字符串(字符串的长度小于numRows，集合长度取s.length)， // 放在集合中。也可以使用字符串数组实现。 //使用StringBuilder可以使字符串拼接更快。 List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) &#123; StringBuilder stringBuilder = new StringBuilder(); rows.add(stringBuilder); &#125; int curRow = 0; //当前行 boolean dir = false; //当前方向 true向下 false向上 for (char c : s.toCharArray()) &#123; rows.get(curRow).append(c); //第一行或最后一行时，换方向 if (curRow ==0 || curRow ==numRows -1 )&#123; dir = ! dir; &#125; //换行 curRow += dir ? 1 : -1; &#125; //拼接字符串集合 StringBuilder str = new StringBuilder(); for (StringBuilder sb : rows) &#123; str.append(sb); &#125; return str.toString(); &#125; 运行耗时：53ms 时间复杂度：O(n) 遍历字符串的长度为len(s)。空间复杂度：O(n) 存储了len(s)的字符。 解决方法2：按行访问(C语言实现)原理：找到每一行中的字符在字符串中的出现位置。 如图： &emsp; &emsp;仔细观察第一行中P和A中间距中间相隔3个子串，实际下标相差4。在图上看的话其实是相差一列加一条对角线，所以第一行的字符位置可以表示为k*(2 * numRows - 2) ，k为字符在一行字符串中所处的位置。最后一行的字符位置可以用第一行加numRows-1表示，所以可以表示为k*(2 * numRows - 2) - numRows -1。中间的字符包含两个部分，分别是 k*(numRows -2) + i 和 （k+1)*(numRows -2) - i。1234567891011121314151617181920212223242526char *convert_2(char *s, int numRows) &#123; if (numRows == 1) &#123; return s; &#125; int length = strlen(s); int cycleLen = 2 * numRows - 2; //长度比原字符串多1，有个'\0' char *ret = (char *) malloc(sizeof(char) * (length + 1)); int index = 0; for (int i = 0; i &lt; numRows; ++i) &#123; for (int j = 0; j + i &lt; length; j += cycleLen) &#123; //第一行、最后一行和中间行的列部分 ret[index++] = s[j + i]; //中间行字符串的对角线部分 if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; j + cycleLen - i &lt; length) &#123; ret[index++] = s[j + cycleLen - i]; &#125; &#125; &#125; ret[index] = '\0'; return ret;&#125; 运行耗时：12ms时间复杂度：O(n) 把所有字符的下标遍历了一遍。空间复杂度：O(n) 分配指针len(s)+1个空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5(Longest Palindromic Substring)]]></title>
    <url>%2F2018%2F12%2F16%2FLeetCode%2Fleetcode5%2F</url>
    <content type="text"><![CDATA[Longest Palindromic Substring（最大回文字符串）1、题目描述：Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2: Input: “cbbd”Output: “bb” 给出一个字符串s，找出长度最大的回文子串，s的最大长度小于1000。 2、摘要：下面介绍了几种方法实现：回文，动态规划和字符串操作。回文的定义：一个字符串从两个方向读，它的内容是相同的。例如：S = “aba”是回文字符串，而S = “abc”不是回文字符串。 3、解决方法：方法1：Brute Force(暴力破解)很明显，暴力破解就是找到所有子串验证它是否是回文字符串。 Java实现：12345678910111213141516171819202122232425public boolean isPalindrome(String s) &#123; String ss = new StringBuilder(s).reverse().toString(); if (ss.equals(s)) &#123; return true; &#125; return false; &#125;public String longestPalindrome(String s) &#123; int longestLength = 0; String longestSubString = ""; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i+1; j &lt;= s.length(); j++) &#123; String subString = s.substring(i,j); if (isPalindrome(subString) &amp;&amp; subString.length()&gt;longestLength)&#123; longestLength = subString.length(); longestSubString = subString; &#125; &#125; &#125; return longestSubString; &#125; 时间复杂度：&emsp;&emsp;两个for循环中嵌套了一个判断回文的过程，回文判断我使用的是StringBuilder的reverse()方法，时间复杂度一共是O(n^3)。比较不理想，提交上去会出现时间超时。 空间复杂度：两个变量，复杂度为O(1)。 方法2：Longest Common Substring(最长的公共子串)&emsp;&emsp;一些人可能会想出一个最快的方法，倒序字符串s，然后与原字符串对比，然后找出最长的公共子串，这个子串一定就是最长的回文子串。&emsp;&emsp;从表面上看这个方法是正确的，但是仔细想来并不是完全正确，例如S = “abacdfgdcaba”,他和倒序的公共最长字符为 “abacd”，然而这个并不是回文字符串。导致出现这个情况的原因是原字符串中存在一个非回文倒序副本。如果要排除这个影响，就要在候选字符串中 检查子串的索引是否与反向子串的原始索引相同，相同就保留，不同就舍弃。 &emsp;&emsp;首先实现寻找最长的公共子串，具体步骤参考：https://blog.csdn.net/u010397369/article/details/38979077&emsp;&emsp;具体实现思路就是把两个字符串组成一个二维数组 ，如果两个对应字符相等，就执行 temp[ i ][ j ] = temp[ i - 1 ][ j - 1] + 1。因为i-1或者j-1会越界，所以可以单独处理。temp[ i ][ j ] 保存的就是公共子串的长度。 Java实现123456789101112131415161718192021222324252627282930public String longestPalindrome_2(String s) &#123; if (s.equals("")) &#123; return ""; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[][] temp = new int[s.length()][ss.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); //原字符串做列,倒序后的子串作为行 for (int i = 0; i &lt; ss_char.length; i++) &#123; for (int j = 0; j &lt; s_char.length; j++) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[i][j] = 1; &#125; else &#123; temp[i][j] = temp[i - 1][j - 1] + 1; &#125; &#125; if (temp[i][j] &gt; longestlength) &#123; longestlength = temp[i][j]; maxEnd = i; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1); &#125; &emsp;&emsp;以上算法只能实现寻找最长的公共子串，如果s=”abc435cba”，公共子串为”abc”，但是这个不是回文字符串。为了解决这个问题，我们还要对比子串在倒序后的字符串的位置和原字符串的位置是否对应。&emsp;&emsp;举个例子，如果s=”caba”,s’ = “abac”，他们的最长回文串为“aba”,“aba”在原字符串中的位置为 1 2 3 ，在s’中的位置为 0 1 2，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。如图：&emsp;&emsp;i所指的字符a在原字符串中的位置为beforeRev = length - i- 1 = 0，beforeRev就是在j中为第一个字符位置，且 beforeRev + temp[i][j] - 1 =2代表j中最后一个字符的位置，如果位置与j相等，aba就是要找的。我们可以写出如下代码：12345678910111213141516171819202122232425262728293031323334//动态规划 (获取最长回文串) 需要和原字符对比位置 public String longestPalindrome_3(String s) &#123; if (s.length() &lt;= 1) &#123; return s; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[][] temp = new int[s.length()][ss.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); //原字符串做列,倒序后的子串作为行 for (int i = 0; i &lt; ss_char.length; i++) &#123; for (int j = 0; j &lt; s_char.length; j++) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[i][j] = 1; &#125; else &#123; temp[i][j] = temp[i - 1][j - 1] + 1; &#125; &#125; if (temp[i][j] &gt; longestlength) &#123; /*******************增加的部分***********************/ int beforeRev = s.length() - i - 1; if (beforeRev + temp[i][j] - 1 == j) &#123; longestlength = temp[i][j]; maxEnd = i; &#125; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1); &#125; 执行时间： 时间复杂度：两个嵌套循环，O(n^2)空间复杂度：一个二维数组，O(n^2) &emsp;&emsp;仔细观察可以发现，我们判断字符相等的只用到了temp[i][j]，一行用过之后就弃置不用了。所以我们可以把空间复杂度优化到O(n)，只需要把一个一维数组重新赋值即可，因为正序赋值有可能覆盖改后面需要使用的数据比如a[3] = a[2]+1时，计算a[4]的时候a[3]的值就不是原来的了。所以我们需要从后往前计算，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public String longestPalindrome_4(String s) &#123; if (s.equals("")) &#123; return ""; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[] temp = new int[s.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); for (int i = 0; i &lt; s_char.length; i++) &#123; //初始化第一行 temp[i] = (s_char[0] == ss_char[i]) ? 1 : 0; &#125; for (int i = 0; i &lt; s_char.length; i++) &#123; for (int j = ss.length() - 1; j &gt;= 0; j--) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[j] = 1; &#125; else &#123; temp[j] = temp[j - 1] + 1; &#125; if (temp[j] &gt; longestlength) &#123; /*******************增加的部分***********************/ int beforeRev = s.length() - j - 1; if (beforeRev + temp[j] - 1 == i) &#123; longestlength = temp[j]; maxEnd = i; &#125; &#125; &#125; else &#123; temp[j] = 0; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1);&#125; 运行时间： 时间复杂度：两个嵌套循环，O(n^2)空间复杂度：一个一维数组，O(n) 方法3：扩展中心&emsp;&emsp;我们观察到一个回文串是从一个中心到两边的镜像。所以，回文串可以从一个字符(奇数)或两个字符(偶数)的为中心拓展，它的中心总共有2n-1个。以i为中心左边为left，右边为right，先令left=right=i，满足left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)时，left—;right++;向外拓展，直到结束。回文的长度就是right - left - 1。实现如下:Java实现：1234567891011121314151617181920212223242526//方法 扩展中心public int expandAroundCenter(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; left--; right++; &#125; return right - left - 1;&#125;public String longestPalindrome_6(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); //奇数 int len2 = expandAroundCenter(s, i, i + 1);//偶数 int len = Math.max(len1, len2); if (len &gt; end - start) &#123; //重新计算start 和end start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125; 运行时间如下：&emsp;&emsp;因为只识别回文序列，过滤掉了很大部分情况，虽然时间复杂度为o(n^2)，但是执行效率更高。时间复杂度：两个嵌套循环，最坏的情况下，O(n^2)空间复杂度：O(1) 参考：https://leetcode.com/problems/longest-palindromic-substring/solution/[](https://leetcode.com/problems/longest-palindromic-substring/solution/)http://windliang.cc/2018/08/05/leetCode-5-Longest-Palindromic-Substring/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4(Median of Two Sorted Arrays)]]></title>
    <url>%2F2018%2F12%2F16%2FLeetCode%2Fleetcode4%2F</url>
    <content type="text"><![CDATA[Median of Two Sorted Arrays题目:There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. 描述：两个已经排序好的数组，数组不是空，求中位数。要求算法的时间复杂度是O(long(m+n))。 分析:1、如果不看时间复杂度的话，可以使用暴力方法实现：把两个数组拼接，然后重新排序，寻找中位数，较为简单，使用Java实现。2、要是考虑复杂度的话，较为困难，后面会用C语言具体分析。 1、Java实现内容简单，这里不做解释。123456789101112131415public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; double median = 0.0f; int m = nums1.length; int n = nums2.length; int[] newNums = Arrays.copyOf(nums1, nums1.length + nums2.length); System.arraycopy(nums2, 0, newNums, nums1.length, nums2.length); Arrays.sort(newNums); if ((m + n) % 2 == 0) &#123; median = (newNums[(m + n) / 2] + newNums[(m + n) / 2 - 1]) / 2.0; &#125; else &#123; median = newNums[(m + n) / 2]; &#125; return median; &#125; 运行时间： 时间复杂度：主要是Arrays.sort()使用的快排，时间复杂度为O( (n+m)*log(n+m) ) 空间复杂度：O(n+m) 2、 C语言实现(1)新建一个长度为 (m+n)/2 +1 的数组newnums，i,j为先指向数组nums1 和mums2的第0个元素,通过i,j的移动把两个源数组的按照升序复制到新数组newnums中。 1. 处理源数组是空的情况，一个如果是空，另一个直接复制数组到newnums中。 2. 两个都不为空，开始循环，循环次数为length/2+1(总长度一半+1) 3. 控制移动边界i&gt;=num1Size时，nums1到最后一个元素，从nums2赋值，j&gt;=num2Size时，nums2到最后一个元素，从nums1赋值。判断nums1[i] &lt; nums2[j],每次都把较小的元素赋值到新数组中。 4.分偶数和奇数判断中位数情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123; int length = nums1Size + nums2Size; int *newnums = (int *) malloc(sizeof(int) * (length / 2 + 1)); int index = 0, i = 0, j = 0; double median; if (nums1Size == 0) &#123; newnums = nums2; &#125; else if (nums2Size == 0) &#123; newnums = nums1; &#125; else &#123; while (index &lt;= length / 2) &#123; if (i &gt;= nums1Size) &#123; newnums[index] = nums2[j]; j++; &#125; else if (j &gt;= nums2Size) &#123; newnums[index] = nums1[i]; i++; &#125; else &#123; if (nums1[i] &lt; nums2[j]) &#123; newnums[index] = nums1[i]; i++; &#125; else &#123; newnums[index] = nums2[j]; j++; &#125; &#125; index++; &#125; &#125; if (length % 2 == 0) &#123; median = (newnums[length / 2 - 1] + newnums[length / 2]) / 2.0; &#125; else &#123; median = newnums[length / 2]; &#125; return median;&#125; 运行时间： 时间复杂度：O((n+m)/2+1) = O(n) 空间复杂度：O((n+m)/2+1) = O(n) 3、C语言实现(2)中位数的定义是把一个集合分为左右长度相等的两个子集合，所以我们如果保证两个数组的，左半部分的长度=右半边分长度，就可以找出中位数。这时候要保证: len(left_part) = len(right_part)max(left_part) &lt;=min(right_part) 令 len(left_part) = i len(right_part)) = ji = m - i j = n - j 因此我们需要确保 i + j = m - i +n - j (or i + j = m - i + n - j + 1)if m&lt;=n 我们需要设置 i ~(0,m) ， j = (m + n + 1)/2 - i nums2[j−1]≤nums1[i] 和 nums1[i−1]≤nums2[j] 我们需要先确保m&lt;=n，如果m&gt;n时，j可能会小于 0，然后使用二分法查询数组，处理好四种边界问 题i = 0 ，j = 0 ，i = m 或 j = n的情况，具体细节看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123; int m = nums1Size; int n = nums2Size; if (m &gt; n) &#123; // to ensure m&lt;=n int *temp = nums1; nums1 = nums2; nums2 = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; iMin = i + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iMax = i - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = nums1[i - 1] &gt; nums2[j - 1] ? nums1[i - 1] : nums2[j - 1]; &#125; if ((m + n) % 2 == 1) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = nums2[j] &gt; nums1[i] ? nums1[i] : nums2[j]; &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0;&#125; 耗时如图： 还是比较不错的。时间复杂度：O(log(min(m,n))).空间复杂度：O(1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3(Longest Substring)]]></title>
    <url>%2F2018%2F12%2F16%2FLeetCode%2Fleetcode3%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating Characters题目描述 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3. 简述：统计字符串不重复字符最长子串的长度。 C语言实现 使用两个下标i，index。i作为字符串的下标，依次往下移动。index为子串的下标往右移动。index+i是在母串移动的位置。初始化子串p比母串大1，不然有的编译器报越界。每次赋值后给下一位赋值&#39;\0&#39;，1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;string.h&gt;int isInclude(char *s, char a) &#123; while (*s != '\0') &#123; if (*s == a) &#123; return 1; &#125; s++; &#125; return 0;&#125;void clear(char *s) &#123; while (*s != '\0') &#123; *s = '\0'; s++; &#125;&#125;int lengthOfLongestSubstring(char *s) &#123; int i = 0, max = 0; int index = 0; char p[strlen(s) &gt; 0 ? strlen(s)+1 : 1]; while (s[i] != '\0') &#123; if (!isInclude(p, s[i + index])) &#123; p[index] = s[i + index]; p[index+1] = '\0'; index++; if (index &gt;= max) &#123; max = index; &#125; if (s[index + i] == '\0') &#123; break; &#125; &#125; else &#123; index = 0; clear(p); i++; &#125; &#125; return max;&#125;int main() &#123; char *s = "vfqsrebtogjmcanajfyzvypzibtngtrca"; int length = lengthOfLongestSubstring(s); printf("LongestLength=%d\n", length); return 0;&#125; 因为C语言没有现成使用的集合类，如（Map,Set），书写起来较为复杂。算法复杂度也挺高。下图为执行耗时，比较不理想。 时间复杂度： 遍历母串加子串移动n(n-1) ，找到一个字符需要从头查找比对。最坏情况为，n(n-1)*n ，时间复杂度O(n^3) 空间复杂度：O(n)+1 Java实现（使用Set实现） 通过集合Set的特性集合中不能出现重复值，检测子串在Set中是否存在，存在的话把集合里面连同本身及之前的元素全部去掉。这种方式被称为SLIDING WINDOW(滑动窗口) 123456789101112131415161718//最初实现 public int lengthOfLongestSubstring_2(String s) &#123; int max = 0; int i = 0, j = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while (i &lt; s.length() &amp;&amp; j &lt; s.length()) &#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); max = Math.max(max, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return max; &#125; 执行流程如下：String s = &quot;abcaea&quot; i set j max j - i 0 a 1 1 1 0 a,b 2 2 2 0 a,b,c 3 3 3 1 b,c 3 3 2 1 b,c,a 4 4 3 1 b,c,a,e 5 4 4 2 c,a,e 5 4 3 3 a,e 5 4 2 4 e 5 4 1 4 ea 6 4 2 算法复杂度 O(2n) =O(n)空间复杂度 O(n) Java实现(HashMap 优化) 使用HashMap自动覆盖重复的key相同的value，记录下每个字符在字符串中出现的最后位置。使用i记录不重复字符子串的起点，j-i-1表示字符串的长度。出现重复字符是更新i的位置。 1234567891011121314151617//HashMap public int lengthOfLongestSubstring_3(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for (int i = 0,j=0; j &lt; s.length(); j++) &#123; if (map.containsKey(s.charAt(j)))&#123; i = Math.max(map.get(s.charAt(j)),i); &#125; max = Math.max(max, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return max; &#125; 时间复杂度：O(n)空间复杂度：O(n)效率比HashSet快的原因是，没有对字符移除的操作，并且HashMap的查询速率把HashSet更快。 Java实现 (使用ASCII 128） 标准ASCll表示从0-127表示128个字符，通过字符代表ASCll值字符位置，数组中存储的是每个字符在字符串中出现的最后位置。是对HashMap实现的优化。因为没有了查询耗时，这种的执行效率最好。 12345678910111213141516public int lengthOfLongestSubstring_4(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125; 时间复杂度：O(n)空间复杂度：O(n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2(Add Two Numbers)]]></title>
    <url>%2F2018%2F12%2F16%2FLeetCode%2Fleetcode2%2F</url>
    <content type="text"><![CDATA[Add Two Numbers题目描述 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 简单描述：两个链表按顺序相加，大于10的取10的余数(%10),向下位进1。 注意点：当最后一个节点的和大于等于10时，需要增加一个节点。 C语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;struct ListNode&#123; int val; struct ListNode *next; &#125;; //创建NULL节点 struct ListNode* newNode(int a)&#123; struct ListNode* newListNode = malloc(sizeof(struct ListNode)); if(newListNode==NULL)&#123; return NULL; &#125; newListNode-&gt;val = a; newListNode-&gt;next = NULL; return newListNode; &#125;//创建 指定长度和数据的链表 struct ListNode* createListNode(long array[],int n)&#123; int i; struct ListNode *head,*p; head = p = newNode(array[0]); for(i=1;i&lt;n;i++)&#123; p-&gt;next = newNode(array[i]); p = p-&gt;next; &#125; return head;&#125;struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode * p1,*p2; p1 = l1; p2 = l2; struct ListNode* head; head = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* p3 = head; int t =0; while(p1!=NULL || p2!=NULL)&#123; int a1 = p1!=NULL? p1-&gt;val : 0; int a2 = p2!=NULL? p2-&gt;val : 0; int sum = a1+a2+t; t = sum/10; p3-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); p3 = p3-&gt;next; p3-&gt;val = sum%10; if(p1!=NULL)&#123; p1 = p1-&gt;next; &#125; if(p2!=NULL)&#123; p2 = p2-&gt;next; &#125; &#125; if(t&gt;0)&#123; p3-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); p3 = p3-&gt;next; p3-&gt;val = t; &#125; p3-&gt;next=NULL; return head-&gt;next;&#125;//测试int main()&#123; struct ListNode *l1,*l2;// int a1[] = &#123;2,4,3&#125;;// int a2[] = &#123;5,6,4&#125;;// l1 = createListNode(a1,3);// l2 = createListNode(a2,3);// long a1[] = &#123;9&#125;;// long a2[] = &#123;1,9,9,9,9,9,9,9,9,9&#125;;// l1 = createListNode(a1,1);// l2 = createListNode(a2,10); long a1[] = &#123;5&#125;; long a2[] = &#123;5&#125;; l1 = createListNode(a1,1); l2 = createListNode(a2,1); struct ListNode *p = addTwoNumbers(l1,l2); while(p!=NULL)&#123; printf("-&gt;%d",p-&gt;val); p = p-&gt;next; &#125; return 0;&#125; 复杂度分析： 时间复杂度：O(max(m,n))， 只有一个while语句，传入的2个链表的最大长度决定循环的次数。 空间复杂度：O(max(m,n))，传入的2个链表的最大空间决定新建链表的最大空间，如果最后节点和大于等于10，空间复杂度为O(max(m,n))+1。 Java实现 123456789101112131415161718192021222324252627public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head= new ListNode(0); ListNode p = l1, q = l2, curr = head; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return head.next;&#125; Java版和C语言版基本一样。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1(Two Sum)]]></title>
    <url>%2F2018%2F12%2F16%2FLeetCode%2Fleetcode1%2F</url>
    <content type="text"><![CDATA[Two Sum题目描述 (md partial supported) Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. C语言实现 通过最简单的方式，两个下标，先保持一个下标i不动，另一个下标j从第一个下标后一个开始移动，j移动到最后一个后，开始移动第一个下标i。12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;//时间复杂度 O(n^2) int* twoSum(int* nums, int numsSize, int target) &#123; int i,j; int * indices = (int*)malloc(2*sizeof(int)); for(i=0;i&lt;numsSize;i++)&#123; for(j=i+1;j&lt;numsSize;j++)&#123; if(nums[i]+nums[j] == target)&#123; *indices = i; *(indices+1)= j; break; &#125; &#125; &#125; return indices;&#125;//测试代码int main()&#123; int i; int a[5] = &#123;2,7,11,15&#125;; int *p = twoSum(a,5,9); for(i=0;i&lt;2;i++)&#123; printf("%d ",*(p+i)); &#125; return 0; &#125; Java实现(优化过) 使用Map集合，Map里存储目标值与数组值之差target-num[i] 和 下标 i，然后判断num[i]是否在Map的key中，不在时继续存储，在时就是所找目标值。这种方式时间复杂度为O(n)，执行效率大大提高。123456789101112131415161718192021public class One &#123; public static void main(String[] args) &#123; One one = new One(); int[] array = one.twoSum(new int[]&#123;2, 7, 11, 15&#125;,10); System.out.println(Arrays.toString(array)); &#125; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(!map.containsKey(nums[i]))&#123; map.put(target-nums[i],i); &#125;else &#123; return new int[]&#123;i,map.get(nums[i])&#125;; &#125; &#125; throw new RuntimeException("no exist"); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

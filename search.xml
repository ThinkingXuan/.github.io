<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[漫谈数据结构(三)——队列]]></title>
    <url>%2F2019%2F01%2F20%2FdataStructure5%2F</url>
    <content type="text"><![CDATA[1、什么是队列&emsp;&emsp;队列是一个先进先出的线性表，它只允许在一端进行插入，在另一端进行删除操作。允许删除的称为队头，允许插入的称为队尾，分别由队头指针和队尾指针来维护队列。 &emsp;&emsp;队头指针指向第一个元素。当有元素出队（删除）时，队头指针向后移动一位，指向下一个元素。 &emsp;&emsp;队尾指针指向最后一个元素的之后的空指针，当有元素入队（插入）时，添加完元素后，队尾指针往后移动一位。&emsp;&emsp;如图所示： 2、顺序队列的实现&emsp;&emsp;使用顺序表实现的队列被称为顺序队列。它的实现和顺序表的实现比较相似，只是只能一端删除，一端插入。如图所示，是一个顺序队列图。 顺序队列的溢出： 真溢出：顺序表分配的空间已满，无法再入队。 假溢出：顺序表分配的空间未满，有出队元素，指针rear已经到达内存的最后一个空间(已经达到了最大下标)，无法再入队。 顺序队列的溢出可以用循环队列来解决，下面会讲到。 2.1 创建12345678910111213typedef struct Queue&#123; int front; //队头指针 int rear; //队尾指针 int data[MAXSIZE]; &#125;SeqQueue;//创建队列 SeqQueue* createSeqQueue()&#123; SeqQueue * queue = (SeqQueue*)malloc(sizeof(SeqQueue)); queue-&gt;front = queue-&gt;rear = -1; memset(queue-&gt;data,0,MAXSIZE*sizeof(int)); return queue;&#125; 2.2 判断是否为空1234567891011//判断是否为空 int isEmpty(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue"); return; &#125; if(queue-&gt;front == queue-&gt;rear)&#123; return 1; &#125; return 0;&#125; 2.3 获取长度1234567891011//获取长度 int getLength(SeqQueue * queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; return queue-&gt;rear - queue-&gt;front; &#125; return 0;&#125; 2.4 入队123456789101112131415161718192021//入队列int pushQueue(SeqQueue *queue,int data)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; //已满 if(queue-&gt;rear == MAXSIZE -1)&#123; printf("the queue already full ,not push!\n"); return; &#125; if(!isEmpty(queue))&#123; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear++; &#125;else&#123; queue-&gt;front = queue-&gt;rear = 0; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear++; &#125; return 1;&#125; 2.5 出队123456789101112131415//出队列int outQueue(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; int temp = queue-&gt;data[queue-&gt;front]; queue-&gt;front++; return temp; &#125;else&#123; printf("queue is null!"); return; &#125;&#125; 2.6 获取队头12345678910111213//获取队头 int getHead(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; return queue-&gt;data[queue-&gt;front]; &#125;else&#123; printf("queue is null!"); return; &#125;&#125; 2.7 其他123456789101112131415161718192021222324252627282930313233343536//清空队列int clearQueue(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; queue-&gt;front = queue-&gt;rear = -1; &#125; return 1;&#125; //销毁队列 int destoryQueue(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; free(queue); return 1;&#125; //打印void print(SeqQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; printf("队头-----------队尾\n"); int i; for(i=queue-&gt;front;i&lt;queue-&gt;rear;i++)&#123; printf("%d ",queue-&gt;data[i]); &#125; printf(" length = %d",getLength(queue)); printf("\n");&#125; 2.8 测试12345678910111213141516171819202122232425262728293031323334353637383940//顺序表实现队列#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #include &lt;string.h&gt;#define MAXSIZE 1024 int main()&#123; printf("Create Seq Queue：\n"); SeqQueue * queue = createSeqQueue(); printf("%d\n\n",queue); printf("Push Seq Queue：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushQueue(queue,i); &#125; print(queue); printf("\n"); printf("Out Seq Queue：\n"); outQueue(queue); print(queue); printf("\n"); printf("Get Head from Queue：\n"); printf("%d\n",getHead(queue)); printf("\n"); printf("clear Queue：\n"); clearQueue(queue); print(queue); printf("Destory Queue：\n"); int flag = destoryQueue(queue); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果： 3、链式队列的实现&emsp;&emsp;用链表来实现的队列称为链式队列，它也是通过队头指针和队尾指针来操作结点。不用出现溢出问题。如图所示： 3.1 实现实现步骤同顺序队列，这里只给出实现代码和测试代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//链式队列 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int data; struct node *next;&#125;Node; typedef struct queue&#123; Node * front; Node * rear; int length;&#125;LinkQueue;//创建队列 LinkQueue* createLinkQueue()&#123; LinkQueue * queue = (LinkQueue*)malloc(sizeof(LinkQueue)); queue-&gt;front = NULL; queue-&gt;rear = NULL; queue-&gt;length = 0; return queue;&#125;//判断是否为空 int isEmpty(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue"); return; &#125; if(queue-&gt;length==0 )&#123; return 1; &#125; return 0;&#125;//获取长度 int getLength(LinkQueue * queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; return queue-&gt;length; &#125; return 0;&#125;//入队列int pushQueue(LinkQueue *queue,int data)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; Node * newNode = (Node*)malloc(sizeof(Node)); newNode-&gt;data = data; if(!isEmpty(queue))&#123; queue-&gt;rear-&gt;next = newNode; queue-&gt;rear = newNode; queue-&gt;length++; &#125;else&#123; queue-&gt;front = newNode; queue-&gt;rear = newNode; queue-&gt;length++; &#125; return 1;&#125; //出队列Node * outQueue(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; Node * node = queue-&gt;front; queue-&gt;front = queue-&gt;front-&gt;next; queue-&gt;length--; return node; &#125;else&#123; printf("queue is null!"); return; &#125;&#125; //获取队头 Node * getHead(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; return queue-&gt;front; &#125;else&#123; printf("queue is null!"); return; &#125;&#125;//清空队列int clearQueue(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; queue-&gt;front = NULL; queue-&gt;rear = NULL; queue-&gt;length = 0; &#125; return 1;&#125; //销毁队列 int destoryQueue(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; free(queue); return 1; &#125; //打印void print(LinkQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; printf("队头-----------队尾\n"); int i; if(!isEmpty(queue))&#123; Node *curNode = queue-&gt;front; for(i=0;i&lt;queue-&gt;length;i++)&#123; printf("%d ",curNode-&gt;data); curNode = curNode-&gt;next; &#125; &#125; printf(" length = %d",getLength(queue)); printf("\n");&#125; 3.2 测试123456789101112131415161718192021222324252627282930313233int main()&#123; printf("Create Link Queue：\n"); LinkQueue * queue = createLinkQueue(); printf("%d\n\n",queue); printf("Push Link Queue：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushQueue(queue,i); &#125; print(queue); printf("\n"); printf("Out Link Queue：\n"); outQueue(queue); print(queue); printf("\n"); printf("Get Head from Link Queue：\n"); printf("%d\n",getHead(queue)-&gt;data); printf("\n"); printf("clear Queue：\n"); clearQueue(queue); print(queue); printf("Destory Queue：\n"); int flag = destoryQueue(queue); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果： 4、循环队列的实现&emsp;&emsp;为了解决顺序队列的假溢出问题，充分利用数组的空间，可以将队列首尾相连，构成一个循环队列。如图所示： 注意点: front==rear时会出现两种情况，队列空和队列满，所以规定最后一个位置不存储数据，当rear在front前一个位置，判断队列已满。 判断空： front==rear 判断已满： (rear+1) % MAXSIZE == front 求队列长度：(rear + MAXSIZE - front) % MAXSIZE 因为rear可能会出现在front前面，导致它们相减可能为负。 由于循环队列其他操作与顺序队列基本一致，故不再贴出相同的代码，如需要完整代码，点击这里。 4.1 部分代码:123456789101112131415161718192021222324252627282930313233343536373839//入队列int pushQueue(CircleQueue *queue,int data)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; //已满 int rear = queue-&gt;rear; int front = queue-&gt;front; if((rear+1) % MAXSIZE == front)&#123; printf("the queue already full ,not push!\n"); return; &#125; if(!isEmpty(queue))&#123; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear = (queue-&gt;rear+1) % MAXSIZE; &#125;else&#123; queue-&gt;front = queue-&gt;rear = 0; queue-&gt;data[queue-&gt;rear] = data; queue-&gt;rear++; &#125; return 1;&#125; //出队列int outQueue(CircleQueue *queue)&#123; if(queue==NULL)&#123; printf("not init queue!\n"); return; &#125; if(!isEmpty(queue))&#123; int temp = queue-&gt;data[queue-&gt;front]; queue-&gt;front = (queue-&gt;front+1) % MAXSIZE; return temp; &#125;else&#123; printf("queue is null!"); return; &#125;&#125; 4.2 测试:123456789101112131415161718192021222324252627282930313233int main()&#123; printf("Create Circle Queue：\n"); CircleQueue * queue = createCircleQueue(); printf("%d\n\n",queue); printf("Push Circle Queue：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushQueue(queue,i); &#125; print(queue); printf("\n"); printf("Out Circle Queue：\n"); outQueue(queue); print(queue); printf("\n"); printf("Get Head from Queue：\n"); printf("%d\n",getHead(queue)); printf("\n"); printf("clear Queue：\n"); clearQueue(queue); print(queue); printf("Destory Queue：\n"); int flag = destoryQueue(queue); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果： 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(三)——栈]]></title>
    <url>%2F2019%2F01%2F19%2FdataStructure4%2F</url>
    <content type="text"><![CDATA[1、什么是栈&emsp;&emsp;栈是一个先进后出的线性表，仅允许在栈的一端进行插入和删除操作。栈中允许插入删除的一端叫做栈顶，另一端叫做栈底。元素的删除叫做出栈，元素的插入叫做入栈。栈满时不能入栈，栈空时不能出栈。 &emsp;&emsp;栈通过一个栈顶指针来执行各种操作，入栈时栈顶指针上移，出栈时栈顶指针下移。如图所示：&emsp;&emsp;栈的常见操作： 创建栈 判断是否是空 出栈 入栈 获取栈顶元素 销毁栈 2、栈的实现2.1 顺序表实现2.1.1 创建栈12345678910typedef struct stack&#123; int data[MAXSIZE]; int top; //栈顶指针 &#125;SeqStack;//创建栈 SeqStack * createSeqStack()&#123; SeqStack *stack = (SeqStack *)malloc(sizeof(SeqStack)); stack-&gt;top = -1;&#125; 2.1.2 判断是否是空1234567891011//判断空int isEmpty(SeqStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(stack-&gt;top == -1)&#123; return 1; &#125; return 0;&#125; 2.1.3 入栈123456789101112131415//入栈 int pushStack(SeqStack *stack,int data)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; //判断是否栈满 if(stack-&gt;top == MAXSIZE-1)&#123; printf("stacl already full!\n"); return -3; &#125; stack-&gt;top++; stack-&gt;data[stack-&gt;top] = data; return 1;&#125; 2.1.4 出栈123456789101112//出栈 int popStack(SeqStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; return stack-&gt;data[stack-&gt;top--]; &#125; return -2;&#125; 2.1.5 获取栈顶元素12345678910111213//获取栈顶元素int getTopStack(SeqStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; return stack-&gt;data[stack-&gt;top]; &#125; return -2;&#125; 2.1.6 销毁栈1234567891011//销毁栈int destoryStack(SeqStack *stack) &#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; free(stack); &#125; return 1;&#125; 2.1.7 打印123456789101112//打印void print(SeqStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return; &#125; int i; for(i=0;i&lt;=stack-&gt;top;i++)&#123; printf("%d ",stack-&gt;data[i]); &#125; printf("\n");&#125; 2.1.8 测试12345678910111213141516171819202122232425262728293031323334//顺序表实现栈 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #define MAXSIZE 1024int main()&#123; printf("Create Stack：\n"); SeqStack * stack = createSeqStack(); printf("%d\n\n",stack); printf("Push Stack：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushStack(stack,i); &#125; print(stack); printf("\n"); printf("Pop Stack：\n"); popStack(stack); print(stack); printf("\n"); printf("Get top from stack：\n"); printf("%d\n",getTopStack(stack)); printf("\n"); printf("Destory stack：\n"); int flag = destoryStack(stack); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果: 2.2 单链表实现&emsp;&emsp;栈的链式存储称为链栈，它和链表的存储方式一样，都可以使用内存中的闲余空间，它用指针来构建结点之间的关系。链栈需要设置一个栈顶指针Top，指向栈顶。链栈是一个单向操作的链表，只能从一端进行操作。 &emsp;&emsp;如图所示： 2.1.1 创建栈123456789101112131415161718typedef struct node&#123; int data; struct node *next;&#125;Node;typedef struct stack&#123; int size; //栈大小 struct node *top; //栈顶指针 &#125;LinkStack;LinkStack * createLinkStack()&#123; LinkStack *stack = (LinkStack *)malloc(sizeof(LinkStack)); if(stack!=NULL)&#123; stack-&gt;top = NULL; stack-&gt;size = 0; &#125; return stack; &#125; 2.1.2 判断是否是空123456789101112//判断空int isEmpty(LinkStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(stack-&gt;top == NULL || stack-&gt;size &lt;=0)&#123; return 1; &#125; return 0;&#125; 2.1.3 入栈1234567891011121314151617181920//入栈 int pushStack(LinkStack *stack,int data)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; Node * node = (Node*)malloc(sizeof(Node)); node-&gt;data = data; if(!isEmpty(stack))&#123; //不是空 node-&gt;next = stack-&gt;top; stack-&gt;top = node; &#125;else&#123; //是空 stack-&gt;top = node; &#125; stack-&gt;size++; return 1;&#125; 2.1.4 出栈123456789101112131415//出栈 Node * popStack(LinkStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; Node * topNode = stack-&gt;top; stack-&gt;top = stack-&gt;top-&gt;next; stack-&gt;size--; return topNode; &#125; return -2;&#125; 2.1.5 获取栈顶元素12345678910111213//获取栈顶元素Node* getTopStack(LinkStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return -1; &#125; if(!isEmpty(stack))&#123; return stack-&gt;top; &#125; return -2;&#125; 2.1.6 打印123456789101112131415161718//打印void print(LinkStack *stack)&#123; if(stack == NULL)&#123; printf("not init stack!\n"); return; &#125; int i; Node * curNode = stack-&gt;top; //curNode指向栈底 printf("栈顶&lt;----------栈底\n"); for(i=0;i&lt;stack-&gt;size;i++)&#123; printf("%d ",curNode-&gt;data); curNode = curNode-&gt;next; &#125; printf("\n");&#125; 2.1.7 测试123456789101112131415161718192021222324252627282930313233//单链表实现栈 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; printf("Create Link Stack：\n"); LinkStack * stack = createLinkStack(); printf("%d\n\n",stack); printf("Push Link Stack：\n"); int i; for(i=0;i&lt;10;i++)&#123; pushStack(stack,i); &#125; print(stack); printf("\n"); printf("Pop Stack：\n"); popStack(stack); print(stack); printf("\n"); printf("Get top from stack：\n"); printf("%d\n",getTopStack(stack)-&gt;data); printf("\n"); printf("Destory stack：\n"); int flag = destoryStack(stack); print(stack); if(flag)&#123; printf("Destory Success!\n"); &#125; return 0;&#125; 输出结果： 3、栈的应用3.1 用栈实现四则运算3.2 栈的递归调用 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(二)——线性表2]]></title>
    <url>%2F2019%2F01%2F18%2FdataStructure3%2F</url>
    <content type="text"><![CDATA[作者个人博客 https://www.you3xuan.top/ 查看原文。 1、线性表的链式存储&emsp;&emsp;在链式存储中，结点之间的内存单元地址是不连续的。它的每一个结点包括数据域和下一个结点的地址。头结点的数据域只存放结点的长度，并指向第一个元素。尾结点指向NULL。如图所示： &emsp;&emsp;因为内存单元不连续，所以哪里空闲的内存，都可以分配一个结点，提高了内存的利用率。又因为结点之间只通过地址连接，所以删除和插入结点效率高。又因为没有索引与结点对应，查找一个结点的时候，必须找到上一个结点，所以查询效率不高。 2、链式存储的实现2.1 创建单链表&emsp;&emsp;分为三部分，创建头结点，创建普通结点，创建单链表。 创建头结点 12345//创建头结点，length存储链表的长度 next指向下一个结点 typedef struct Header&#123; int length; struct Header * next;&#125;Head; 创建普通结点 12345//创建一个结点，data存放数据，next指向下一个结点 typedef struct Node&#123; int data; struct Node *next; &#125;ListNode; 创建链表 1234567//创建一个链表，返回头结点 Head * createList()&#123; Head *phead = (Head*)malloc(sizeof(Head)); phead-&gt;length = 0; phead-&gt;next = NULL; return phead;&#125; 2.2 获取链表长度12345678// 获取链表长度int getLength(Head * phead)&#123; if(phead==NULL)&#123; printf(&quot;not init headnode!\n&quot;); return -1; &#125; return phead-&gt;length;&#125; 2.3 添加结点1234567891011121314151617181920212223// 添加数据，,默认添加在末尾 int addData(Head * phead, int data)&#123; if(phead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; //创建当前结点，并指向链表最后一个结点 ListNode * curNode = phead; while(curNode-&gt;next!=NULL)&#123; curNode = curNode-&gt;next; &#125; //创建新结点 ListNode * newNode = (ListNode*)malloc(sizeof(ListNode)); newNode-&gt;data = data; newNode-&gt;next = NULL; //连接结点 curNode-&gt;next = newNode; phead-&gt;length++; return 1; &#125; &emsp;&emsp;如图所示，添加结点需要两个结点，一个当前结点，指向尾结点，另一个是要添加的新结点，指向NULL,使用当前结点的next指向新结点，就完成了添加结点的操作。因为当前结点是指向尾结点的，当前结点的next就相当于尾结点的next，所有就相当于尾结点的next指向了新结点。最后别忘把头结点的length加1。 2.4 插入结点12345678910111213141516171819202122232425262728// 插入数据 int insertData(Head * pHead, int data, int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt; pHead-&gt;length)&#123; printf("insert postion error!\n"); return -2; &#125; //创建新结点 ListNode * newNode = (ListNode *)malloc(sizeof(ListNode)); newNode-&gt;data = data; //创建当前结点 ListNode * curNode = pHead; int i; for(i=0;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; newNode-&gt;next = curNode-&gt;next; curNode-&gt;next = newNode; pHead-&gt;length++; return 1; &#125; &emsp;&emsp;同样，插入也需要两个结点，一个结点指向要插入的位置的前一个结点，起名为当前结点。另一个为新结点。主要就是两行代码：12newNode-&gt;next = curNode-&gt;next;curNode-&gt;next = newNode; &emsp;&emsp;当前结点指向待插入位置的前一个结点，起名为前结点(lastNode)。以上代码相当于：12newNode-&gt;next = lastNode-&gt;next;lastNode-&gt;next = newNode; &emsp;&emsp;因为lastNode-&gt;next指向下一个结点。现在使用newNode-&gt;next指向下一个结点。然后使用lastNode-&gt;next指向newNode。就完成了插入操作。&emsp;&emsp;两行代码不可颠倒位置，因为先执行第二行代码的话，会导致后面结点全部丢失。 2.5 删除结点1234567891011121314151617181920212223// 删除数据 int deleteData(Head * pHead,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt;= pHead-&gt;length)&#123; printf("delete postion error!\n"); return -2; &#125; //创建当前结点 ListNode * curNode = pHead; int i; for(i=0;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; curNode-&gt;next = curNode-&gt;next-&gt;next; pHead-&gt;length--; return 1;&#125; &emsp;&emsp;当前结点指定要删除位置的上一个结点(前结点)，把前结点的next指向下一个结点的next,curNode-&gt;next = curNode-&gt;next-&gt;next,就完成了删除操作。 2.6 获取指定位置的结点12345678910111213141516171819//获取数据 int getData(Head * pHead,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt;= pHead-&gt;length)&#123; printf("postion error!\n"); return -2; &#125; //创建当前结点 ListNode * curNode = pHead; int i; for(i=0;i&lt;=pos;i++)&#123; curNode = curNode-&gt;next; &#125; return curNode-&gt;data;&#125; 2.7 打印所有结点1234567891011121314//打印 void print(Head * phead)&#123; if(phead==NULL)&#123; printf("not init headnode!\n"); return 0; &#125; ListNode * node = phead-&gt;next; while(node-&gt;next!=NULL)&#123; printf("%d-&gt;",node-&gt;data); node = node-&gt;next; &#125; printf("%d length=%d\n",node-&gt;data,phead-&gt;length);&#125; &emsp;&emsp;为了让打印效果更好，想法去掉了最后一个-&gt;，并且输出链表的长度。 2.8 测试1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i; printf("create ListNode:\n"); Head* pHead = createList(); printf("length=%d\n\n",pHead-&gt;length); printf("add data:\n"); for(i=0;i&lt;10;i++)&#123; addData(pHead,i); &#125; print(pHead) ; printf("\n"); printf("insert data:\n"); insertData(pHead,100,3); print(pHead); printf("\n"); printf("delete data:\n"); deleteData(pHead,3); print(pHead); printf("\n"); printf("get data:\n"); printf("%d\n",getData(pHead,5)); printf("\n"); return 0;&#125; 输出结果： 3、双链表实现链式存储定义&emsp;&emsp;前面使用单链表实现了线性表的链式存储。但是单链表有个缺点，无法访问前驱结点。当查找到一个元素结点时，如果想要找到前面的元素结点，需要从头开始遍历，比较麻烦。所有双链表有开辟了一个空间,存储结点前驱结点的地址。如图所示： &emsp;&emsp;双链表的实现和单链表类似，当我们插入一个新结点时，如果这个结点有后驱结点时，要是后驱结点的pre 指向新结点，新结点的pre也要指向它的前驱结点。其他操作类似，这里只贴出代码，就不详细解释了。 3.1 创建双链表12345678910111213141516171819202122typedef struct Header&#123; int length; struct Header * pre; //为了方便，在头结点添加一个pre ，不然无法指向 Node,在Head后面添加结点时就需要单独判断。 struct Header * next;&#125;Head;typedef struct Node&#123; int data; struct Node * pre; struct Node * next;&#125;NodeList;//创建 Head * createDouNodeList()&#123; Head * pHead = (Head*)malloc(sizeof(Head)); if(pHead == NULL)&#123; printf("create failure!\n"); &#125; pHead-&gt;length = 0; pHead-&gt;next = NULL; return pHead;&#125; 3.2 获取链表长度12345678// 获取链表长度int getLength(Head * pHead)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; return pHead-&gt;length;&#125; 3.3 判断是否为空123456789101112//判断是否为空int isEmpty(Head *pHead)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pHead-&gt;length==0)&#123; return 1; &#125;else&#123; return 0; &#125;&#125; 3.4 添加结点1234567891011121314151617181920212223// 添加结点，,默认添加在末尾 int addDataDou(Head * pHead, int data)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; //创建当前结点，并指向链表最后一个结点 NodeList * curNode = pHead; while(curNode-&gt;next != NULL)&#123; curNode = curNode-&gt;next; &#125; //创建新结点 NodeList * newNode = (NodeList*)malloc(sizeof(NodeList)); newNode-&gt;data = data; newNode-&gt;next = NULL; curNode-&gt;next = newNode; newNode-&gt;pre = curNode; pHead-&gt;length++; return 1;&#125; 3.5 插入结点1234567891011121314151617181920212223242526272829303132//插入 int insertDou(Head *pHead,int data,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos&lt;=0||pos&gt;=pHead-&gt;length)&#123; printf("insert positon error!\n"); return -2; &#125; //创建新结点 NodeList * newNode = (NodeList*)malloc(sizeof(NodeList)); newNode-&gt;data = data; //创建当前结点,并指向 指定位置之前的那个结点 NodeList * curNode = pHead; int i; for(i=0;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; //连接 newNode-&gt;next = curNode-&gt;next; curNode-&gt;next-&gt;pre = newNode; newNode-&gt;pre = curNode; curNode-&gt;next = newNode; pHead-&gt;length++; return 1;&#125; 3.6 删除结点1234567891011121314151617181920212223242526272829//删除 int deleteDataDou(Head * pHead,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt;= pHead-&gt;length)&#123; printf("delete postion error!\n"); return -2; &#125; //创建当前结点 NodeList * curNode = pHead; int i; for(i=0;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; curNode-&gt;next = curNode-&gt;next-&gt;next; //要删除最后一个结点时判断 if(curNode-&gt;next!=NULL)&#123; curNode-&gt;next-&gt;pre = curNode; &#125; pHead-&gt;length--; return 1;&#125; 3.7 获取指定元素的结点12345678910111213141516//查找某个元素，返回它的结点 NodeList * findNodeDou(Head *pHead,int val)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return 0; &#125; NodeList *curNode = pHead-&gt;next; do&#123; if(curNode-&gt;data == val)&#123; return curNode; &#125; curNode = curNode-&gt;next; &#125;while(curNode-&gt;next!=NULL); return NULL;&#125; 3.8 打印所有结点12345678910111213//打印 void print(Head * pHead)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return 0; &#125; NodeList * node = pHead-&gt;next; while(node-&gt;next!=NULL)&#123; printf("%d&lt;-&gt;",node-&gt;data); node = node-&gt;next; &#125; printf("%d length=%d\n",node-&gt;data,pHead-&gt;length);&#125; 3.9 测试123456789101112131415161718192021222324252627282930313233343536//双链表实现链式存储 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main()&#123; int i; printf("Create Double Node List: \n"); Head *pHead = createDouNodeList(); printf("length = %d\n",pHead-&gt;length); printf("\n"); printf("Add Data: \n"); for(i=0;i&lt;10;i++)&#123; addDataDou(pHead,i); &#125; print(pHead); printf("\n"); printf("Insert Data: \n"); insertDou(pHead,100,3); print(pHead); printf("\n"); printf("delete Data: \n"); deleteDataDou(pHead,3); print(pHead); printf("\n"); printf("find Node: \n"); NodeList * node = findNodeDou(pHead,3); printf("node is %d\n",node); printf("\n"); return 0;&#125; 输出结果： 4、循环链表&emsp;&emsp;链表还有一种常用的形式，那就是循环链表。循环链表首尾相接，形成一个环，从链表任何一个结点出发，都能够找到其他所有结点。 &emsp;&emsp;循环链表分为单向循环链表，双循环链表，多重循环链表。如图所示： &emsp;&emsp;上图是单向循环链表，形成一个闭合环，有一个方向。&emsp;&emsp;上图是双向循环链表，形成一个闭合环，有两个方向。&emsp;&emsp;上图是多重循环链表，形成了两个闭合环。 &emsp;&emsp;本教程只讲解单向循环链表，其他两种比较复杂，如需要的话，自行搜索。 循环链表的创建和查找基本和单链表一样，这里就不过多讲解了，只讲解插入和删除。如果您还不太清楚，请认真阅读前面的知识。 4.1 插入结点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int insertCircleList(Head * pHead,int data,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt; pHead-&gt;length)&#123; printf("insert postion error!\n"); return -2; &#125; //创建新结点 NodeList * newNode = (NodeList*)malloc(sizeof(NodeList)); newNode-&gt;data = data; //如果是空 if(isEmpty(pHead))&#123; pHead-&gt;next = newNode; //直接插入到头结点后面 newNode-&gt;next = newNode; //自己指向自己 &#125;else&#123; NodeList *curNode = pHead-&gt;next; //因为pos ==0为涉及到头结点，单独处理 if(pos==0)&#123; //curNode指向尾结点 while(curNode-&gt;next!=pHead-&gt;next)&#123; curNode = curNode-&gt;next; &#125; newNode-&gt;next =pHead-&gt;next; pHead-&gt;next = newNode; curNode-&gt;next = newNode; &#125;else&#123; //使curNode指向插入位置的前一个结点 int i; for(i=1;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; newNode-&gt;next = curNode-&gt;next; curNode-&gt;next = newNode; &#125; &#125; pHead-&gt;length++; return 1;&#125; 4.2 删除结点12345678910111213141516171819202122232425262728293031323334int deleteCircleNode(Head *pHead,int pos)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pos &lt; 0||pos &gt; pHead-&gt;length)&#123; printf("insert postion error!\n"); return -2; &#125; NodeList *curNode = pHead-&gt;next; if(isEmpty(pHead))&#123; return -3; &#125;else&#123; if(pos==0)&#123; while(curNode-&gt;next!=pHead-&gt;next)&#123; curNode = curNode-&gt;next; &#125; curNode-&gt;next = curNode -&gt;next-&gt;next; pHead-&gt;next = curNode -&gt;next; &#125;else&#123; int i; for(i=1;i&lt;pos;i++)&#123; curNode = curNode-&gt;next; &#125; curNode -&gt;next = curNode-&gt;next-&gt;next; &#125; &#125; pHead-&gt;length--; return 1; &#125; 4.3 其他代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//创建头结点，length存储链表的长度 next指向下一个结点 typedef struct Header&#123; int length; struct Header * next;&#125;Head;//创建一个结点，data存放数据，next指向下一个结点 typedef struct Node&#123; int data; struct Node *next; &#125;NodeList;//创建一个链表，返回头结点 Head * createList()&#123; Head *phead = (Head*)malloc(sizeof(Head)); phead-&gt;length = 0; phead-&gt;next = NULL; return phead;&#125;//判断是否为空int isEmpty(Head *pHead)&#123; if(pHead==NULL)&#123; printf("not init head node!\n"); return -1; &#125; if(pHead-&gt;length==0)&#123; return 1; &#125;else&#123; return 0; &#125;&#125;//打印 void print(Head *pHead)&#123; if(pHead==NULL)&#123; printf("not init headnode!\n"); return 0; &#125; NodeList * node = pHead-&gt;next; do&#123; printf("%d-&gt;",node-&gt;data); node = node-&gt;next; &#125;while(node!=pHead-&gt;next); printf(" length=%d\n",pHead-&gt;length);&#125; 4.4 测试12345678910111213141516171819202122//循环链表#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int i; printf("Create Circle Node List: \n"); Head * pHead = createList(); printf("length = %d\n",pHead-&gt;length); printf("\n"); printf("Insert Node: \n"); for(i=0;i&lt;11;i++)&#123; insertCircleList(pHead,i,i); &#125; print(pHead); printf("\n"); printf("Delete Node: \n"); deleteCircleNode(pHead,0); print(pHead); return 0;&#125; 输出结果： 本文为线性表第二篇，如果读者想了解第一篇，请点击这里。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(二)——线性表1]]></title>
    <url>%2F2019%2F01%2F17%2FdataStructure2%2F</url>
    <content type="text"><![CDATA[1、线性表的定义和特征1.1 定义&emsp;&emsp;线性表是具有相同类型元素组成的一个线性序列。元素的个数即为元素的长度，元素为0时称为空表。如下： (A,B,C,D,E,F,G)&emsp;&emsp;这就表示一个线性表。 1.2 特征 有且只有一个头结点，头结点没有前驱结点。 有且只有一个尾结点, 尾结点没有后继节点。 除头尾结点外，其他结点都有一个前驱结点和后继节点。 1.3 存储特征&emsp;&emsp;线性表的存储结构分为顺序存储和链式存储，它们都具有如下特点： 唯一性：一个线性表只能存储一种类型的元素 有序性：各元素在线性表中的位置只取决于它的序号，数据元素之间的相对位置为线性的（并不是内存结构上的有序）。 1.4 基本操作 创建 create() 初始化 init() 添加数据 addData() 获取长度 getLength() 获取指定元素 get() 插入 insert() 删除 delete() 清空表 clear() 这8种只是线性表的最基本操作，如果想要进阶，请自己谷歌。 2、线性表的顺序存储&emsp;&emsp;数据被存储在指定长度的连续存储单元，通过对应的索引(一般从0开始)找到对应的元素。在高级语言中，顺序存储可以用数组表示。 &emsp;&emsp;前面提到过线性表的顺序存储查询效率高，插入和删除效率低。适合存储需要连续存取的数据。 2.1 顺序存储的实现2.1.1 创建顺序表并初始化&emsp;&emsp;使用结构体创建一个结点，这个结点存储了这个顺序表的基本信息，包括capacity,length,node。为了简单起见，只存储整形数据，其中用到了malloc和memset函数 ，代码如下： 12345678910#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//创建结点typedef struct SeqList &#123; //包含表的各种属性 int capacity; // 容量 int length; //长度 int * node; //指针数组&#125; HSeqList; 123456789101112131415161718192021222324//创建顺序表HSeqList * createSeqList(int capacity) &#123; int ret; HSeqList * head = (HSeqList *)malloc(sizeof(HSeqList)); if(head == NULL) &#123; ret = 1; printf("create seqList error %d\n",ret); return NULL; &#125; memset(head,0,sizeof(HSeqList)); //清空头结点 head-&gt;capacity = capacity; head-&gt;length = 0; head-&gt;node = (int *) malloc(sizeof(void *)*capacity); if(head-&gt;node == NULL) &#123; ret = 2; printf("create seqList error %d\n",ret); return NULL; &#125; return head;&#125; 2.1.2 获取长度，容量并且封装打印方法。123456789101112131415161718192021222324252627282930313233//求顺序表容量int getCapacity(HSeqList * list) &#123; HSeqList * temp = NULL; if(list == NULL) &#123; return; &#125; temp = list; return temp-&gt;capacity;&#125;//求顺序表长度int getLength(HSeqList * list) &#123; HSeqList * temp = NULL; if(list == NULL) &#123; return; &#125; temp = list; return temp-&gt;length;&#125;//输出void print(HSeqList * list)&#123; if(list == NULL) &#123; printf("not init SeqList\n"); return; &#125; int length = getLength(list); int i; printf("["); for(i=0;i&lt;length-1;i++)&#123; printf("%d,",list-&gt;node[i]); &#125; printf("%d]\n",list-&gt;node[i]);&#125; 2.1.3 添加数据123456789101112131415//添加数据int addData(HSeqList * list,int data) &#123; if(list == NULL)&#123; printf("not init SeqList\n"); return 0; &#125; if(list-&gt;length&gt;=list-&gt;capacity)&#123; printf("SeqList is full,not add data,current data is %d\n",data); return 0; &#125; int index = list-&gt;length; list-&gt;node[index] = data; list-&gt;length++; return 1;&#125; 2.1.4 插入&emsp;&emsp;如果要在顺序表中插入数据，则需要将该位置后的所有元素往后移动。例如，在[A,B,C,D,E,F]中把G插入到第二个位置。要先移位然后插入。如图所示： 代码如下：123456789101112131415161718192021222324252627//插入int insert(HSeqList *list,int data,int pos)&#123; int i; if(list == NULL) &#123; printf("not init SeqList\n"); return -1; &#125; if(list-&gt;length&gt;=list-&gt;capacity)&#123; printf("SeqList is full,not insert data,current data is %d\n",data); return -2; &#125; //如何插入位置在length之前，则默认插入到最后一位 if(pos&gt;list-&gt;length)&#123; pos = list-&gt;length; &#125; //从后往前移位，防止数据丢失 for(i=list-&gt;length;i&gt;pos;i--)&#123; list-&gt;node[i] = list-&gt;node[i-1]; &#125; //插入数据 list-&gt;node[i] = data; //增加长度 list-&gt;length ++; return 1;&#125; 2.1.5 删除&emsp;&emsp;删除指定位置的元素后，该位置往后的元素依次往前移动。1234567891011121314151617181920212223 delete(HSeqList *list, int pos) &#123; if(list == NULL) &#123; printf("not init SeqList!\n"); return -1; &#125; if(list-&gt;length &lt;= 0) &#123; printf("SeqList not data!\n"); return -2; &#125; if(pos &lt; 0 || pos &gt;list-&gt;length)&#123; printf("delete position error!\n"); return -3; &#125; int i; for(i=pos; i&lt;=list-&gt;length;i++)&#123; list-&gt;node[i] = list-&gt;node[i+1]; &#125; list-&gt;length--; return 1;&#125; 2.1.6 查找某个位置上的指定元素 12345678910111213//查找某个位置上的指定元素int getData(HSeqList *list,int pos)&#123; if(list == NULL) &#123; printf("not init SeqList!\n"); return -1; &#125; if(pos &lt; 0 || pos &gt;=list-&gt;length)&#123; printf("position error!\n"); return -3; &#125; return list-&gt;node[pos];&#125; 2.1.7 清空表12345678910//清空表int clear(HSeqList *list)&#123; if(list == NULL) &#123; printf("not init SeqList!\n"); return -1; &#125; list-&gt;length = 0; memset(list-&gt;node,0,(list-&gt;capacity * sizeof(void *))); return 1;&#125; 2.1.8 测试代码123456789101112131415161718192021222324252627282930int main() &#123; printf("init:\n"); int capacity = 100; HSeqList *list = createSeqList(capacity); int s = getCapacity(list); printf("Capacity = %d\n",s); printf("addData:\n"); int i; for(i=0; i&lt;10; i++) &#123; addData(list,i); &#125; print(list); printf("insert:\n"); insert(list,100,3); print(list); printf("delete:\n"); delete(list,3); print(list); printf("getData:\n"); printf("index %d is %d\n",0,getData(list,0)); printf("clear:\n"); clear(list); print(list); return 0;&#125; 输出结果： 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈数据结构(一)—— 概述]]></title>
    <url>%2F2019%2F01%2F16%2FdataStructure1%2F</url>
    <content type="text"><![CDATA[1、为什么要学习数据结构？&emsp; &emsp;数据结构是是计算机专业最重要的基础之一，它是大学计算机专业的必修课，也是程序员提高自己的重要知识结构。对于学生而言，它对你以后考研和面试都用很重要的帮助。对于程序员而言，它能拓宽人的学习深度，决定了你日后能到达怎样的高度，更能体现人的学习素养，对日后的工作面试有很大的用途。 &emsp; &emsp;本教程主要介绍数据结构的常见用法，为了兼容更多人群，所有以C语言为主要的编程语言。如果您C语言基础不过关，请自行Google。其次，语言只是描述程序的一种形式，万变不离其中，掌握一种也就很容易掌握另外一种。 2、什么是数据结构？维基百科给出了定义: 数据结构（英语：data structure）是计算机中存储、组织数据的方式。无论是大数据时代的海量数据的存储，还是简单用户信息或者学生信息的存储，其数据存储的底层都要以某种更方便、更快捷且更省内存空间的方式进行，这种存储方式就是数据结构。如下图，就是一个简单的数据结构，他描述一个基础的学生信息，由id,name,sex,class组成。 id name sex class 001 张三 男 1班 002 李四 男 2班 003 王五 男 3班 2.1、基本术语 数据 &emsp; &emsp;计算机中存储的的最小单位 数据元素 &emsp; &emsp; 也叫元素或记录，及为上表中的一行。 数据对象 &emsp; &emsp; 数据元素的集合 3、数据结构的分类3.1、逻辑结构 描述元素之间的逻辑关系，与数据的存储位置无关。他包括集合、线性结构，树形结构和图形结构。 1、集合&emsp; &emsp; 类似于数学中的集合，一个数据存在于集合中，数据之间没有什么关系。 2、线性结构&emsp; &emsp; 与元素具有一对一的关系，在内存中逐个排列。它分为顺序存储和链式存储，顺序存储相当于高级语言的数组，在内存中排列是连续的。链式存储使用链表维护元素，在内存中排列是不连续的。 3、树形结构&emsp; &emsp; 使用树来维护元素的多个层次关系（对二叉树不了解请点击链接），除根结点外，一个节点只有一个父结点，可以根据一个节点寻找它的子结点或者父结点。 4、图形结构&emsp;&emsp;使用图)来维护元素的多个层次关系（图不了解请点击链接），一个图中的结点可以有多个父结点和子结点。 3.2、存储结构1、顺序存储结构&emsp;&emsp;使用顺序表来存储数据，数据存储在是连续的内存单元上。 优点：查询效率高，可以使用元素的下标直接找到某一个元素。因为其存储结构是紧密的，所以提高了空间利用率。 缺点：插入和删除一个元素的效率低，插入或者删除一个元素，要把这个元素的右边所有元素右移或者左移1个单位，随着数据量的增大，插入和删除的效率也会随之下降。且存储空间大小在定义时已经明确指定，操作元素是会出现“溢出”或者浪费空间的情况。 2、链式存储结构&emsp;&emsp;使用链表来存储数据，数据存储在是不连续的内存单元上。 优点：插入和删除效率很高，不会造成空间的浪费。 缺点：无法随机访问，内存单元一部分用来存储元素之间的逻辑关系，造成空间利用率低。 3、索引存储结构&emsp;&emsp;除建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引表由若干索引项组成 &emsp;&emsp;特点：索引存储结构是用结点的索引号来确定结点存储地址，其优点是检索速度快，缺点是增加了附加的索引表,会占用较多的存储空间。 4、散列存储结构&emsp;&emsp;散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。 &emsp;&emsp;散列法存储的基本思想是：由节点的关键码值决定节点的存储地址。散列技术除了可以用于查找外，还可以用于存储。 &emsp;&emsp;特点：散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的。 4、算法程序 = 数据结构 + 算法 算法是数据结构的灵魂，一个数据结构设计的再好，如果没有算法，如同失去了灵魂，它的存在就毫无意义。 4.1 什么是算法&emsp;&emsp;算法是解决某个特定问题的具体步骤。 &emsp;&emsp;描述算法的方法：伪代码法，N-S结构化流程图和流程图， 具体方法请自行百度。 4.2 算法的特性 确定性 可行性 有穷性 零个或者多个输入 一个或者多个输出 正确性 可读性 健壮性 高效率和低存储 4.3 算法的复杂度&emsp;&emsp;用来表示算法执行消耗的计算机资源，主要从时间和空间两个方面考虑。 1、时间复杂度&emsp;&emsp;描述算法的执行时间(次数)，常用O(n)表示。推导方法: n为常数，用1代替。 n为未知数，系数为1，只保留最高阶项。 n为未知数，系数不为1，只保留最高阶项且最高阶项除去系数。 例子如下：123int a = 1;int b = 2;int sum = a + b; 共执行$f（n）= 3$ 次，所以 时间复杂度为O(1)。 1234567void fun()&#123; int i,sum; //执行一次 for(i=0;i&lt;n;i++)&#123; sum += i; //执行n次 &#125; printf("%d\n",sum); //执行一次&#125; 共执行$f（n）= n+3 $次，所以 时间复杂度为O(n)。 123456void fun()&#123; int i = 1; while(i &lt; n)&#123; i * = 2; &#125;&#125; 共执行$ 2^f = n $, 即 $ f = {log_2{n}}$，所以复杂度为O(logn)。 2、空间复杂度&emsp;&emsp;算法运行所占空间的大小，常用O(n)表示。 4、算法和数据结构&emsp;&emsp;算法通常是决定程序效率的关键，但是一切算法最终都要在相应的数据结构上实现，许多算法的精髓就是在于选择了合适的数据结构作为基础。在程序设计中，不但要注重算法设计，也要正确选择数据结构，这样往往能够事半功倍。 具体参考如下:LeetCode1 使用散列存储，极大的提高了算法效率。 作者个人博客 https://www.you3xuan.top/ 查看原文。 源码地址: https://github.com/ThinkingXuan/DataStructure 如果对您有帮助，随手一个Star吧。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6(ZigZag Conversion)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode6%2F</url>
    <content type="text"><![CDATA[ZigZag Conversion（ZigZag转换）1、题目描述：The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P &emsp;&emsp; &emsp;A &emsp;&emsp;&emsp;H &emsp; &emsp; &emsp;NA &emsp;P &emsp; L&emsp; S&emsp; I&emsp; &emsp;I &emsp; GY &emsp;&emsp;&emsp; I &emsp;&emsp;&emsp; RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows);Example 1: Input: s = “PAYPALISHIRING”, numRows = 3Output: “PAHNAPLSIIGYIR” &emsp; &emsp;给出一个指定字符串和numRows，把字符串按倒Z的形式排列，行数为numRows，按行排列返回字符串。 2、解决方法1：按行分类(Java实现)&emsp; &emsp;仔细观察这个Z型的图形，它是由nomRows行子串构成。所以可以遍历整个字符串把字符依次添加到指定行字符串上，方向为先下后上。 123456789101112131415161718192021222324252627282930313233343536373839public String convert(String s, int numRows) &#123; //numRows为1，直接返回s if (numRows==1)&#123; return s; &#125; //构建Math.min(numRows, s.length())个字符串(字符串的长度小于numRows，集合长度取s.length)， // 放在集合中。也可以使用字符串数组实现。 //使用StringBuilder可以使字符串拼接更快。 List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) &#123; StringBuilder stringBuilder = new StringBuilder(); rows.add(stringBuilder); &#125; int curRow = 0; //当前行 boolean dir = false; //当前方向 true向下 false向上 for (char c : s.toCharArray()) &#123; rows.get(curRow).append(c); //第一行或最后一行时，换方向 if (curRow ==0 || curRow ==numRows -1 )&#123; dir = ! dir; &#125; //换行 curRow += dir ? 1 : -1; &#125; //拼接字符串集合 StringBuilder str = new StringBuilder(); for (StringBuilder sb : rows) &#123; str.append(sb); &#125; return str.toString(); &#125; 运行耗时：53ms 时间复杂度：O(n) 遍历字符串的长度为len(s)。空间复杂度：O(n) 存储了len(s)的字符。 解决方法2：按行访问(C语言实现)原理：找到每一行中的字符在字符串中的出现位置。 如图： &emsp; &emsp;仔细观察第一行中P和A中间距中间相隔3个子串，实际下标相差4。在图上看的话其实是相差一列加一条对角线，所以第一行的字符位置可以表示为k*(2 * numRows - 2) ，k为字符在一行字符串中所处的位置。最后一行的字符位置可以用第一行加numRows-1表示，所以可以表示为k*(2 * numRows - 2) - numRows -1。中间的字符包含两个部分，分别是 k*(numRows -2) + i 和 （k+1)*(numRows -2) - i。1234567891011121314151617181920212223242526char *convert_2(char *s, int numRows) &#123; if (numRows == 1) &#123; return s; &#125; int length = strlen(s); int cycleLen = 2 * numRows - 2; //长度比原字符串多1，有个'\0' char *ret = (char *) malloc(sizeof(char) * (length + 1)); int index = 0; for (int i = 0; i &lt; numRows; ++i) &#123; for (int j = 0; j + i &lt; length; j += cycleLen) &#123; //第一行、最后一行和中间行的列部分 ret[index++] = s[j + i]; //中间行字符串的对角线部分 if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; j + cycleLen - i &lt; length) &#123; ret[index++] = s[j + cycleLen - i]; &#125; &#125; &#125; ret[index] = '\0'; return ret;&#125; 运行耗时：12ms时间复杂度：O(n) 把所有字符的下标遍历了一遍。空间复杂度：O(n) 分配指针len(s)+1个空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5(Longest Palindromic Substring)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode5%2F</url>
    <content type="text"><![CDATA[Longest Palindromic Substring（最大回文字符串）1、题目描述：Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2: Input: “cbbd”Output: “bb” 给出一个字符串s，找出长度最大的回文子串，s的最大长度小于1000。 2、摘要：下面介绍了几种方法实现：回文，动态规划和字符串操作。回文的定义：一个字符串从两个方向读，它的内容是相同的。例如：S = “aba”是回文字符串，而S = “abc”不是回文字符串。 3、解决方法：方法1：Brute Force(暴力破解)很明显，暴力破解就是找到所有子串验证它是否是回文字符串。 Java实现：12345678910111213141516171819202122232425public boolean isPalindrome(String s) &#123; String ss = new StringBuilder(s).reverse().toString(); if (ss.equals(s)) &#123; return true; &#125; return false; &#125;public String longestPalindrome(String s) &#123; int longestLength = 0; String longestSubString = ""; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i+1; j &lt;= s.length(); j++) &#123; String subString = s.substring(i,j); if (isPalindrome(subString) &amp;&amp; subString.length()&gt;longestLength)&#123; longestLength = subString.length(); longestSubString = subString; &#125; &#125; &#125; return longestSubString; &#125; 时间复杂度：&emsp;&emsp;两个for循环中嵌套了一个判断回文的过程，回文判断我使用的是StringBuilder的reverse()方法，时间复杂度一共是O(n^3)。比较不理想，提交上去会出现时间超时。 空间复杂度：两个变量，复杂度为O(1)。 方法2：Longest Common Substring(最长的公共子串)&emsp;&emsp;一些人可能会想出一个最快的方法，倒序字符串s，然后与原字符串对比，然后找出最长的公共子串，这个子串一定就是最长的回文子串。&emsp;&emsp;从表面上看这个方法是正确的，但是仔细想来并不是完全正确，例如S = “abacdfgdcaba”,他和倒序的公共最长字符为 “abacd”，然而这个并不是回文字符串。导致出现这个情况的原因是原字符串中存在一个非回文倒序副本。如果要排除这个影响，就要在候选字符串中 检查子串的索引是否与反向子串的原始索引相同，相同就保留，不同就舍弃。 &emsp;&emsp;首先实现寻找最长的公共子串，具体步骤参考：https://blog.csdn.net/u010397369/article/details/38979077&emsp;&emsp;具体实现思路就是把两个字符串组成一个二维数组 ，如果两个对应字符相等，就执行 temp[ i ][ j ] = temp[ i - 1 ][ j - 1] + 1。因为i-1或者j-1会越界，所以可以单独处理。temp[ i ][ j ] 保存的就是公共子串的长度。 Java实现123456789101112131415161718192021222324252627282930public String longestPalindrome_2(String s) &#123; if (s.equals("")) &#123; return ""; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[][] temp = new int[s.length()][ss.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); //原字符串做列,倒序后的子串作为行 for (int i = 0; i &lt; ss_char.length; i++) &#123; for (int j = 0; j &lt; s_char.length; j++) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[i][j] = 1; &#125; else &#123; temp[i][j] = temp[i - 1][j - 1] + 1; &#125; &#125; if (temp[i][j] &gt; longestlength) &#123; longestlength = temp[i][j]; maxEnd = i; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1); &#125; &emsp;&emsp;以上算法只能实现寻找最长的公共子串，如果s=”abc435cba”，公共子串为”abc”，但是这个不是回文字符串。为了解决这个问题，我们还要对比子串在倒序后的字符串的位置和原字符串的位置是否对应。&emsp;&emsp;举个例子，如果s=”caba”,s’ = “abac”，他们的最长回文串为“aba”,“aba”在原字符串中的位置为 1 2 3 ，在s’中的位置为 0 1 2，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。如图：&emsp;&emsp;i所指的字符a在原字符串中的位置为beforeRev = length - i- 1 = 0，beforeRev就是在j中为第一个字符位置，且 beforeRev + temp[i][j] - 1 =2代表j中最后一个字符的位置，如果位置与j相等，aba就是要找的。我们可以写出如下代码：12345678910111213141516171819202122232425262728293031323334//动态规划 (获取最长回文串) 需要和原字符对比位置 public String longestPalindrome_3(String s) &#123; if (s.length() &lt;= 1) &#123; return s; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[][] temp = new int[s.length()][ss.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); //原字符串做列,倒序后的子串作为行 for (int i = 0; i &lt; ss_char.length; i++) &#123; for (int j = 0; j &lt; s_char.length; j++) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[i][j] = 1; &#125; else &#123; temp[i][j] = temp[i - 1][j - 1] + 1; &#125; &#125; if (temp[i][j] &gt; longestlength) &#123; /*******************增加的部分***********************/ int beforeRev = s.length() - i - 1; if (beforeRev + temp[i][j] - 1 == j) &#123; longestlength = temp[i][j]; maxEnd = i; &#125; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1); &#125; 执行时间： 时间复杂度：两个嵌套循环，O(n^2)空间复杂度：一个二维数组，O(n^2) &emsp;&emsp;仔细观察可以发现，我们判断字符相等的只用到了temp[i][j]，一行用过之后就弃置不用了。所以我们可以把空间复杂度优化到O(n)，只需要把一个一维数组重新赋值即可，因为正序赋值有可能覆盖改后面需要使用的数据比如a[3] = a[2]+1时，计算a[4]的时候a[3]的值就不是原来的了。所以我们需要从后往前计算，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public String longestPalindrome_4(String s) &#123; if (s.equals("")) &#123; return ""; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[] temp = new int[s.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); for (int i = 0; i &lt; s_char.length; i++) &#123; //初始化第一行 temp[i] = (s_char[0] == ss_char[i]) ? 1 : 0; &#125; for (int i = 0; i &lt; s_char.length; i++) &#123; for (int j = ss.length() - 1; j &gt;= 0; j--) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[j] = 1; &#125; else &#123; temp[j] = temp[j - 1] + 1; &#125; if (temp[j] &gt; longestlength) &#123; /*******************增加的部分***********************/ int beforeRev = s.length() - j - 1; if (beforeRev + temp[j] - 1 == i) &#123; longestlength = temp[j]; maxEnd = i; &#125; &#125; &#125; else &#123; temp[j] = 0; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1);&#125; 运行时间： 时间复杂度：两个嵌套循环，O(n^2)空间复杂度：一个一维数组，O(n) 方法3：扩展中心&emsp;&emsp;我们观察到一个回文串是从一个中心到两边的镜像。所以，回文串可以从一个字符(奇数)或两个字符(偶数)的为中心拓展，它的中心总共有2n-1个。以i为中心左边为left，右边为right，先令left=right=i，满足left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)时，left—;right++;向外拓展，直到结束。回文的长度就是right - left - 1。实现如下:Java实现：1234567891011121314151617181920212223242526//方法 扩展中心public int expandAroundCenter(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; left--; right++; &#125; return right - left - 1;&#125;public String longestPalindrome_6(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); //奇数 int len2 = expandAroundCenter(s, i, i + 1);//偶数 int len = Math.max(len1, len2); if (len &gt; end - start) &#123; //重新计算start 和end start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125; 运行时间如下：&emsp;&emsp;因为只识别回文序列，过滤掉了很大部分情况，虽然时间复杂度为o(n^2)，但是执行效率更高。时间复杂度：两个嵌套循环，最坏的情况下，O(n^2)空间复杂度：O(1) 参考：https://leetcode.com/problems/longest-palindromic-substring/solution/[](https://leetcode.com/problems/longest-palindromic-substring/solution/)http://windliang.cc/2018/08/05/leetCode-5-Longest-Palindromic-Substring/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4(Median of Two Sorted Arrays)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode4%2F</url>
    <content type="text"><![CDATA[Median of Two Sorted Arrays题目:There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. 描述：两个已经排序好的数组，数组不是空，求中位数。要求算法的时间复杂度是O(long(m+n))。 分析:1、如果不看时间复杂度的话，可以使用暴力方法实现：把两个数组拼接，然后重新排序，寻找中位数，较为简单，使用Java实现。2、要是考虑复杂度的话，较为困难，后面会用C语言具体分析。 1、Java实现内容简单，这里不做解释。123456789101112131415public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; double median = 0.0f; int m = nums1.length; int n = nums2.length; int[] newNums = Arrays.copyOf(nums1, nums1.length + nums2.length); System.arraycopy(nums2, 0, newNums, nums1.length, nums2.length); Arrays.sort(newNums); if ((m + n) % 2 == 0) &#123; median = (newNums[(m + n) / 2] + newNums[(m + n) / 2 - 1]) / 2.0; &#125; else &#123; median = newNums[(m + n) / 2]; &#125; return median; &#125; 运行时间： 时间复杂度：主要是Arrays.sort()使用的快排，时间复杂度为O( (n+m)*log(n+m) ) 空间复杂度：O(n+m) 2、 C语言实现(1)新建一个长度为 (m+n)/2 +1 的数组newnums，i,j为先指向数组nums1 和mums2的第0个元素,通过i,j的移动把两个源数组的按照升序复制到新数组newnums中。 1. 处理源数组是空的情况，一个如果是空，另一个直接复制数组到newnums中。 2. 两个都不为空，开始循环，循环次数为length/2+1(总长度一半+1) 3. 控制移动边界i&gt;=num1Size时，nums1到最后一个元素，从nums2赋值，j&gt;=num2Size时，nums2到最后一个元素，从nums1赋值。判断nums1[i] &lt; nums2[j],每次都把较小的元素赋值到新数组中。 4.分偶数和奇数判断中位数情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123; int length = nums1Size + nums2Size; int *newnums = (int *) malloc(sizeof(int) * (length / 2 + 1)); int index = 0, i = 0, j = 0; double median; if (nums1Size == 0) &#123; newnums = nums2; &#125; else if (nums2Size == 0) &#123; newnums = nums1; &#125; else &#123; while (index &lt;= length / 2) &#123; if (i &gt;= nums1Size) &#123; newnums[index] = nums2[j]; j++; &#125; else if (j &gt;= nums2Size) &#123; newnums[index] = nums1[i]; i++; &#125; else &#123; if (nums1[i] &lt; nums2[j]) &#123; newnums[index] = nums1[i]; i++; &#125; else &#123; newnums[index] = nums2[j]; j++; &#125; &#125; index++; &#125; &#125; if (length % 2 == 0) &#123; median = (newnums[length / 2 - 1] + newnums[length / 2]) / 2.0; &#125; else &#123; median = newnums[length / 2]; &#125; return median;&#125; 运行时间： 时间复杂度：O((n+m)/2+1) = O(n) 空间复杂度：O((n+m)/2+1) = O(n) 3、C语言实现(2)中位数的定义是把一个集合分为左右长度相等的两个子集合，所以我们如果保证两个数组的，左半部分的长度=右半边分长度，就可以找出中位数。这时候要保证: len(left_part) = len(right_part)max(left_part) &lt;=min(right_part) 令 len(left_part) = i len(right_part)) = ji = m - i j = n - j 因此我们需要确保 i + j = m - i +n - j (or i + j = m - i + n - j + 1)if m&lt;=n 我们需要设置 i ~(0,m) ， j = (m + n + 1)/2 - i nums2[j−1]≤nums1[i] 和 nums1[i−1]≤nums2[j] 我们需要先确保m&lt;=n，如果m&gt;n时，j可能会小于 0，然后使用二分法查询数组，处理好四种边界问 题i = 0 ，j = 0 ，i = m 或 j = n的情况，具体细节看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123; int m = nums1Size; int n = nums2Size; if (m &gt; n) &#123; // to ensure m&lt;=n int *temp = nums1; nums1 = nums2; nums2 = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; iMin = i + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iMax = i - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = nums1[i - 1] &gt; nums2[j - 1] ? nums1[i - 1] : nums2[j - 1]; &#125; if ((m + n) % 2 == 1) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = nums2[j] &gt; nums1[i] ? nums1[i] : nums2[j]; &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0;&#125; 耗时如图： 还是比较不错的。时间复杂度：O(log(min(m,n))).空间复杂度：O(1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3(Longest Substring)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode3%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating Characters题目描述 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3. 简述：统计字符串不重复字符最长子串的长度。 C语言实现 使用两个下标i，index。i作为字符串的下标，依次往下移动。index为子串的下标往右移动。index+i是在母串移动的位置。初始化子串p比母串大1，不然有的编译器报越界。每次赋值后给下一位赋值&#39;\0&#39;，1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;string.h&gt;int isInclude(char *s, char a) &#123; while (*s != '\0') &#123; if (*s == a) &#123; return 1; &#125; s++; &#125; return 0;&#125;void clear(char *s) &#123; while (*s != '\0') &#123; *s = '\0'; s++; &#125;&#125;int lengthOfLongestSubstring(char *s) &#123; int i = 0, max = 0; int index = 0; char p[strlen(s) &gt; 0 ? strlen(s)+1 : 1]; while (s[i] != '\0') &#123; if (!isInclude(p, s[i + index])) &#123; p[index] = s[i + index]; p[index+1] = '\0'; index++; if (index &gt;= max) &#123; max = index; &#125; if (s[index + i] == '\0') &#123; break; &#125; &#125; else &#123; index = 0; clear(p); i++; &#125; &#125; return max;&#125;int main() &#123; char *s = "vfqsrebtogjmcanajfyzvypzibtngtrca"; int length = lengthOfLongestSubstring(s); printf("LongestLength=%d\n", length); return 0;&#125; 因为C语言没有现成使用的集合类，如（Map,Set），书写起来较为复杂。算法复杂度也挺高。下图为执行耗时，比较不理想。 时间复杂度： 遍历母串加子串移动n(n-1) ，找到一个字符需要从头查找比对。最坏情况为，n(n-1)*n ，时间复杂度O(n^3) 空间复杂度：O(n)+1 Java实现（使用Set实现） 通过集合Set的特性集合中不能出现重复值，检测子串在Set中是否存在，存在的话把集合里面连同本身及之前的元素全部去掉。这种方式被称为SLIDING WINDOW(滑动窗口) 123456789101112131415161718//最初实现 public int lengthOfLongestSubstring_2(String s) &#123; int max = 0; int i = 0, j = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while (i &lt; s.length() &amp;&amp; j &lt; s.length()) &#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); max = Math.max(max, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return max; &#125; 执行流程如下：String s = &quot;abcaea&quot; i set j max j - i 0 a 1 1 1 0 a,b 2 2 2 0 a,b,c 3 3 3 1 b,c 3 3 2 1 b,c,a 4 4 3 1 b,c,a,e 5 4 4 2 c,a,e 5 4 3 3 a,e 5 4 2 4 e 5 4 1 4 ea 6 4 2 算法复杂度 O(2n) =O(n)空间复杂度 O(n) Java实现(HashMap 优化) 使用HashMap自动覆盖重复的key相同的value，记录下每个字符在字符串中出现的最后位置。使用i记录不重复字符子串的起点，j-i-1表示字符串的长度。出现重复字符是更新i的位置。 1234567891011121314151617//HashMap public int lengthOfLongestSubstring_3(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for (int i = 0,j=0; j &lt; s.length(); j++) &#123; if (map.containsKey(s.charAt(j)))&#123; i = Math.max(map.get(s.charAt(j)),i); &#125; max = Math.max(max, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return max; &#125; 时间复杂度：O(n)空间复杂度：O(n)效率比HashSet快的原因是，没有对字符移除的操作，并且HashMap的查询速率把HashSet更快。 Java实现 (使用ASCII 128） 标准ASCll表示从0-127表示128个字符，通过字符代表ASCll值字符位置，数组中存储的是每个字符在字符串中出现的最后位置。是对HashMap实现的优化。因为没有了查询耗时，这种的执行效率最好。 12345678910111213141516public int lengthOfLongestSubstring_4(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125; 时间复杂度：O(n)空间复杂度：O(n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2(Add Two Numbers)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode2%2F</url>
    <content type="text"><![CDATA[Add Two Numbers题目描述 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 简单描述：两个链表按顺序相加，大于10的取10的余数(%10),向下位进1。 注意点：当最后一个节点的和大于等于10时，需要增加一个节点。 C语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;struct ListNode&#123; int val; struct ListNode *next; &#125;; //创建NULL节点 struct ListNode* newNode(int a)&#123; struct ListNode* newListNode = malloc(sizeof(struct ListNode)); if(newListNode==NULL)&#123; return NULL; &#125; newListNode-&gt;val = a; newListNode-&gt;next = NULL; return newListNode; &#125;//创建 指定长度和数据的链表 struct ListNode* createListNode(long array[],int n)&#123; int i; struct ListNode *head,*p; head = p = newNode(array[0]); for(i=1;i&lt;n;i++)&#123; p-&gt;next = newNode(array[i]); p = p-&gt;next; &#125; return head;&#125;struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode * p1,*p2; p1 = l1; p2 = l2; struct ListNode* head; head = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* p3 = head; int t =0; while(p1!=NULL || p2!=NULL)&#123; int a1 = p1!=NULL? p1-&gt;val : 0; int a2 = p2!=NULL? p2-&gt;val : 0; int sum = a1+a2+t; t = sum/10; p3-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); p3 = p3-&gt;next; p3-&gt;val = sum%10; if(p1!=NULL)&#123; p1 = p1-&gt;next; &#125; if(p2!=NULL)&#123; p2 = p2-&gt;next; &#125; &#125; if(t&gt;0)&#123; p3-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); p3 = p3-&gt;next; p3-&gt;val = t; &#125; p3-&gt;next=NULL; return head-&gt;next;&#125;//测试int main()&#123; struct ListNode *l1,*l2;// int a1[] = &#123;2,4,3&#125;;// int a2[] = &#123;5,6,4&#125;;// l1 = createListNode(a1,3);// l2 = createListNode(a2,3);// long a1[] = &#123;9&#125;;// long a2[] = &#123;1,9,9,9,9,9,9,9,9,9&#125;;// l1 = createListNode(a1,1);// l2 = createListNode(a2,10); long a1[] = &#123;5&#125;; long a2[] = &#123;5&#125;; l1 = createListNode(a1,1); l2 = createListNode(a2,1); struct ListNode *p = addTwoNumbers(l1,l2); while(p!=NULL)&#123; printf("-&gt;%d",p-&gt;val); p = p-&gt;next; &#125; return 0;&#125; 复杂度分析： 时间复杂度：O(max(m,n))， 只有一个while语句，传入的2个链表的最大长度决定循环的次数。 空间复杂度：O(max(m,n))，传入的2个链表的最大空间决定新建链表的最大空间，如果最后节点和大于等于10，空间复杂度为O(max(m,n))+1。 Java实现 123456789101112131415161718192021222324252627public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head= new ListNode(0); ListNode p = l1, q = l2, curr = head; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return head.next;&#125; Java版和C语言版基本一样。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1(Two Sum)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode1%2F</url>
    <content type="text"><![CDATA[Two Sum题目描述 (md partial supported) Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. C语言实现 通过最简单的方式，两个下标，先保持一个下标i不动，另一个下标j从第一个下标后一个开始移动，j移动到最后一个后，开始移动第一个下标i。12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;//时间复杂度 O(n^2) int* twoSum(int* nums, int numsSize, int target) &#123; int i,j; int * indices = (int*)malloc(2*sizeof(int)); for(i=0;i&lt;numsSize;i++)&#123; for(j=i+1;j&lt;numsSize;j++)&#123; if(nums[i]+nums[j] == target)&#123; *indices = i; *(indices+1)= j; break; &#125; &#125; &#125; return indices;&#125;//测试代码int main()&#123; int i; int a[5] = &#123;2,7,11,15&#125;; int *p = twoSum(a,5,9); for(i=0;i&lt;2;i++)&#123; printf("%d ",*(p+i)); &#125; return 0; &#125; Java实现(优化过) 使用Map集合，Map里存储目标值与数组值之差target-num[i] 和 下标 i，然后判断num[i]是否在Map的key中，不在时继续存储，在时就是所找目标值。这种方式时间复杂度为O(n)，执行效率大大提高。123456789101112131415161718192021public class One &#123; public static void main(String[] args) &#123; One one = new One(); int[] array = one.twoSum(new int[]&#123;2, 7, 11, 15&#125;,10); System.out.println(Arrays.toString(array)); &#125; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(!map.containsKey(nums[i]))&#123; map.put(target-nums[i],i); &#125;else &#123; return new int[]&#123;i,map.get(nums[i])&#125;; &#125; &#125; throw new RuntimeException("no exist"); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

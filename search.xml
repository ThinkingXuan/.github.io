<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[包天宇为什么那么牛逼！]]></title>
    <url>%2F2019%2F01%2F12%2F2019%E5%B9%B41%E6%9C%8812%E6%97%A5151225%2F</url>
    <content type="text"><![CDATA[包天宇为什么那么牛逼！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6(ZigZag Conversion)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode6%2F</url>
    <content type="text"><![CDATA[ZigZag Conversion（ZigZag转换）1、题目描述：The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P &emsp;&emsp; &emsp;A &emsp;&emsp;&emsp;H &emsp; &emsp; &emsp;NA &emsp;P &emsp; L&emsp; S&emsp; I&emsp; &emsp;I &emsp; GY &emsp;&emsp;&emsp; I &emsp;&emsp;&emsp; RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows);Example 1: Input: s = “PAYPALISHIRING”, numRows = 3Output: “PAHNAPLSIIGYIR” &emsp; &emsp;给出一个指定字符串和numRows，把字符串按倒Z的形式排列，行数为numRows，按行排列返回字符串。 2、解决方法1：按行分类(Java实现)&emsp; &emsp;仔细观察这个Z型的图形，它是由nomRows行子串构成。所以可以遍历整个字符串把字符依次添加到指定行字符串上，方向为先下后上。 123456789101112131415161718192021222324252627282930313233343536373839public String convert(String s, int numRows) &#123; //numRows为1，直接返回s if (numRows==1)&#123; return s; &#125; //构建Math.min(numRows, s.length())个字符串(字符串的长度小于numRows，集合长度取s.length)， // 放在集合中。也可以使用字符串数组实现。 //使用StringBuilder可以使字符串拼接更快。 List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) &#123; StringBuilder stringBuilder = new StringBuilder(); rows.add(stringBuilder); &#125; int curRow = 0; //当前行 boolean dir = false; //当前方向 true向下 false向上 for (char c : s.toCharArray()) &#123; rows.get(curRow).append(c); //第一行或最后一行时，换方向 if (curRow ==0 || curRow ==numRows -1 )&#123; dir = ! dir; &#125; //换行 curRow += dir ? 1 : -1; &#125; //拼接字符串集合 StringBuilder str = new StringBuilder(); for (StringBuilder sb : rows) &#123; str.append(sb); &#125; return str.toString(); &#125; 运行耗时：53ms 时间复杂度：O(n) 遍历字符串的长度为len(s)。空间复杂度：O(n) 存储了len(s)的字符。 解决方法2：按行访问(C语言实现)原理：找到每一行中的字符在字符串中的出现位置。 如图： &emsp; &emsp;仔细观察第一行中P和A中间距中间相隔3个子串，实际下标相差4。在图上看的话其实是相差一列加一条对角线，所以第一行的字符位置可以表示为k*(2 * numRows - 2) ，k为字符在一行字符串中所处的位置。最后一行的字符位置可以用第一行加numRows-1表示，所以可以表示为k*(2 * numRows - 2) - numRows -1。中间的字符包含两个部分，分别是 k*(numRows -2) + i 和 （k+1)*(numRows -2) - i。1234567891011121314151617181920212223242526char *convert_2(char *s, int numRows) &#123; if (numRows == 1) &#123; return s; &#125; int length = strlen(s); int cycleLen = 2 * numRows - 2; //长度比原字符串多1，有个'\0' char *ret = (char *) malloc(sizeof(char) * (length + 1)); int index = 0; for (int i = 0; i &lt; numRows; ++i) &#123; for (int j = 0; j + i &lt; length; j += cycleLen) &#123; //第一行、最后一行和中间行的列部分 ret[index++] = s[j + i]; //中间行字符串的对角线部分 if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; j + cycleLen - i &lt; length) &#123; ret[index++] = s[j + cycleLen - i]; &#125; &#125; &#125; ret[index] = '\0'; return ret;&#125; 运行耗时：12ms时间复杂度：O(n) 把所有字符的下标遍历了一遍。空间复杂度：O(n) 分配指针len(s)+1个空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5(Longest Palindromic Substring)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode5%2F</url>
    <content type="text"><![CDATA[Longest Palindromic Substring（最大回文字符串）1、题目描述：Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2: Input: “cbbd”Output: “bb” 给出一个字符串s，找出长度最大的回文子串，s的最大长度小于1000。 2、摘要：下面介绍了几种方法实现：回文，动态规划和字符串操作。回文的定义：一个字符串从两个方向读，它的内容是相同的。例如：S = “aba”是回文字符串，而S = “abc”不是回文字符串。 3、解决方法：方法1：Brute Force(暴力破解)很明显，暴力破解就是找到所有子串验证它是否是回文字符串。 Java实现：12345678910111213141516171819202122232425public boolean isPalindrome(String s) &#123; String ss = new StringBuilder(s).reverse().toString(); if (ss.equals(s)) &#123; return true; &#125; return false; &#125;public String longestPalindrome(String s) &#123; int longestLength = 0; String longestSubString = ""; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i+1; j &lt;= s.length(); j++) &#123; String subString = s.substring(i,j); if (isPalindrome(subString) &amp;&amp; subString.length()&gt;longestLength)&#123; longestLength = subString.length(); longestSubString = subString; &#125; &#125; &#125; return longestSubString; &#125; 时间复杂度：&emsp;&emsp;两个for循环中嵌套了一个判断回文的过程，回文判断我使用的是StringBuilder的reverse()方法，时间复杂度一共是O(n^3)。比较不理想，提交上去会出现时间超时。 空间复杂度：两个变量，复杂度为O(1)。 ######方法2：Longest Common Substring(最长的公共子串)&emsp;&emsp;一些人可能会想出一个最快的方法，倒序字符串s，然后与原字符串对比，然后找出最长的公共子串，这个子串一定就是最长的回文子串。&emsp;&emsp;从表面上看这个方法是正确的，但是仔细想来并不是完全正确，例如S = “abacdfgdcaba”,他和倒序的公共最长字符为 “abacd”，然而这个并不是回文字符串。导致出现这个情况的原因是原字符串中存在一个非回文倒序副本。如果要排除这个影响，就要在候选字符串中 检查子串的索引是否与反向子串的原始索引相同，相同就保留，不同就舍弃。 &emsp;&emsp;首先实现寻找最长的公共子串，具体步骤参考：https://blog.csdn.net/u010397369/article/details/38979077&emsp;&emsp;具体实现思路就是把两个字符串组成一个二维数组 ，如果两个对应字符相等，就执行 temp[ i ][ j ] = temp[ i - 1 ][ j - 1] + 1。因为i-1或者j-1会越界，所以可以单独处理。temp[ i ][ j ] 保存的就是公共子串的长度。 Java实现123456789101112131415161718192021222324252627282930public String longestPalindrome_2(String s) &#123; if (s.equals("")) &#123; return ""; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[][] temp = new int[s.length()][ss.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); //原字符串做列,倒序后的子串作为行 for (int i = 0; i &lt; ss_char.length; i++) &#123; for (int j = 0; j &lt; s_char.length; j++) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[i][j] = 1; &#125; else &#123; temp[i][j] = temp[i - 1][j - 1] + 1; &#125; &#125; if (temp[i][j] &gt; longestlength) &#123; longestlength = temp[i][j]; maxEnd = i; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1); &#125; &emsp;&emsp;以上算法只能实现寻找最长的公共子串，如果s=”abc435cba”，公共子串为”abc”，但是这个不是回文字符串。为了解决这个问题，我们还要对比子串在倒序后的字符串的位置和原字符串的位置是否对应。&emsp;&emsp;举个例子，如果s=”caba”,s’ = “abac”，他们的最长回文串为“aba”,“aba”在原字符串中的位置为 1 2 3 ，在s’中的位置为 0 1 2，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。如图：&emsp;&emsp;i所指的字符a在原字符串中的位置为beforeRev = length - i- 1 = 0，beforeRev就是在j中为第一个字符位置，且 beforeRev + temp[i][j] - 1 =2代表j中最后一个字符的位置，如果位置与j相等，aba就是要找的。我们可以写出如下代码：12345678910111213141516171819202122232425262728293031323334//动态规划 (获取最长回文串) 需要和原字符对比位置 public String longestPalindrome_3(String s) &#123; if (s.length() &lt;= 1) &#123; return s; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[][] temp = new int[s.length()][ss.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); //原字符串做列,倒序后的子串作为行 for (int i = 0; i &lt; ss_char.length; i++) &#123; for (int j = 0; j &lt; s_char.length; j++) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[i][j] = 1; &#125; else &#123; temp[i][j] = temp[i - 1][j - 1] + 1; &#125; &#125; if (temp[i][j] &gt; longestlength) &#123; /*******************增加的部分***********************/ int beforeRev = s.length() - i - 1; if (beforeRev + temp[i][j] - 1 == j) &#123; longestlength = temp[i][j]; maxEnd = i; &#125; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1); &#125; 执行时间： 时间复杂度：两个嵌套循环，O(n^2)空间复杂度：一个二维数组，O(n^2) &emsp;&emsp;仔细观察可以发现，我们判断字符相等的只用到了temp[i][j]，一行用过之后就弃置不用了。所以我们可以把空间复杂度优化到O(n)，只需要把一个一维数组重新赋值即可，因为正序赋值有可能覆盖改后面需要使用的数据比如a[3] = a[2]+1时，计算a[4]的时候a[3]的值就不是原来的了。所以我们需要从后往前计算，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public String longestPalindrome_4(String s) &#123; if (s.equals("")) &#123; return ""; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[] temp = new int[s.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); for (int i = 0; i &lt; s_char.length; i++) &#123; //初始化第一行 temp[i] = (s_char[0] == ss_char[i]) ? 1 : 0; &#125; for (int i = 0; i &lt; s_char.length; i++) &#123; for (int j = ss.length() - 1; j &gt;= 0; j--) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[j] = 1; &#125; else &#123; temp[j] = temp[j - 1] + 1; &#125; if (temp[j] &gt; longestlength) &#123; /*******************增加的部分***********************/ int beforeRev = s.length() - j - 1; if (beforeRev + temp[j] - 1 == i) &#123; longestlength = temp[j]; maxEnd = i; &#125; &#125; &#125; else &#123; temp[j] = 0; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1);&#125; 运行时间： 时间复杂度：两个嵌套循环，O(n^2)空间复杂度：一个一维数组，O(n) 方法3：扩展中心&emsp;&emsp;我们观察到一个回文串是从一个中心到两边的镜像。所以，回文串可以从一个字符(奇数)或两个字符(偶数)的为中心拓展，它的中心总共有2n-1个。以i为中心左边为left，右边为right，先令left=right=i，满足left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)时，left–;right++;向外拓展，直到结束。回文的长度就是right - left - 1。实现如下:Java实现：1234567891011121314151617181920212223242526//方法 扩展中心public int expandAroundCenter(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; left--; right++; &#125; return right - left - 1;&#125;public String longestPalindrome_6(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); //奇数 int len2 = expandAroundCenter(s, i, i + 1);//偶数 int len = Math.max(len1, len2); if (len &gt; end - start) &#123; //重新计算start 和end start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125; 运行时间如下：&emsp;&emsp;因为只识别回文序列，过滤掉了很大部分情况，虽然时间复杂度为o(n^2)，但是执行效率更高。时间复杂度：两个嵌套循环，最坏的情况下，O(n^2)空间复杂度：O(1) 参考：https://leetcode.com/problems/longest-palindromic-substring/solution/[](https://leetcode.com/problems/longest-palindromic-substring/solution/)http://windliang.cc/2018/08/05/leetCode-5-Longest-Palindromic-Substring/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4(Median of Two Sorted Arrays)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode4%2F</url>
    <content type="text"><![CDATA[Median of Two Sorted Arrays题目:There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. 描述：两个已经排序好的数组，数组不是空，求中位数。要求算法的时间复杂度是O(long(m+n))。 分析:1、如果不看时间复杂度的话，可以使用暴力方法实现：把两个数组拼接，然后重新排序，寻找中位数，较为简单，使用Java实现。2、要是考虑复杂度的话，较为困难，后面会用C语言具体分析。 1、Java实现内容简单，这里不做解释。123456789101112131415public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; double median = 0.0f; int m = nums1.length; int n = nums2.length; int[] newNums = Arrays.copyOf(nums1, nums1.length + nums2.length); System.arraycopy(nums2, 0, newNums, nums1.length, nums2.length); Arrays.sort(newNums); if ((m + n) % 2 == 0) &#123; median = (newNums[(m + n) / 2] + newNums[(m + n) / 2 - 1]) / 2.0; &#125; else &#123; median = newNums[(m + n) / 2]; &#125; return median; &#125; 运行时间： 时间复杂度：主要是Arrays.sort()使用的快排，时间复杂度为O( (n+m)*log(n+m) ) 空间复杂度：O(n+m) 2、 C语言实现(1)新建一个长度为 (m+n)/2 +1 的数组newnums，i,j为先指向数组nums1 和mums2的第0个元素,通过i,j的移动把两个源数组的按照升序复制到新数组newnums中。 1. 处理源数组是空的情况，一个如果是空，另一个直接复制数组到newnums中。 2. 两个都不为空，开始循环，循环次数为length/2+1(总长度一半+1) 3. 控制移动边界i&gt;=num1Size时，nums1到最后一个元素，从nums2赋值，j&gt;=num2Size时，nums2到最后一个元素，从nums1赋值。判断nums1[i] &lt; nums2[j],每次都把较小的元素赋值到新数组中。 4.分偶数和奇数判断中位数情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123; int length = nums1Size + nums2Size; int *newnums = (int *) malloc(sizeof(int) * (length / 2 + 1)); int index = 0, i = 0, j = 0; double median; if (nums1Size == 0) &#123; newnums = nums2; &#125; else if (nums2Size == 0) &#123; newnums = nums1; &#125; else &#123; while (index &lt;= length / 2) &#123; if (i &gt;= nums1Size) &#123; newnums[index] = nums2[j]; j++; &#125; else if (j &gt;= nums2Size) &#123; newnums[index] = nums1[i]; i++; &#125; else &#123; if (nums1[i] &lt; nums2[j]) &#123; newnums[index] = nums1[i]; i++; &#125; else &#123; newnums[index] = nums2[j]; j++; &#125; &#125; index++; &#125; &#125; if (length % 2 == 0) &#123; median = (newnums[length / 2 - 1] + newnums[length / 2]) / 2.0; &#125; else &#123; median = newnums[length / 2]; &#125; return median;&#125; 运行时间： 时间复杂度：O((n+m)/2+1) = O(n) 空间复杂度：O((n+m)/2+1) = O(n) 3、C语言实现(2)中位数的定义是把一个集合分为左右长度相等的两个子集合，所以我们如果保证两个数组的，左半部分的长度=右半边分长度，就可以找出中位数。这时候要保证: len(left_part) = len(right_part)max(left_part) &lt;=min(right_part) 令 len(left_part) = i len(right_part)) = ji = m - i j = n - j 因此我们需要确保 i + j = m - i +n - j (or i + j = m - i + n - j + 1)if m&lt;=n 我们需要设置 i ~(0,m) ， j = (m + n + 1)/2 - i nums2[j−1]≤nums1[i] 和 nums1[i−1]≤nums2[j] 我们需要先确保m&lt;=n，如果m&gt;n时，j可能会小于 0，然后使用二分法查询数组，处理好四种边界问 题i = 0 ，j = 0 ，i = m 或 j = n的情况，具体细节看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123; int m = nums1Size; int n = nums2Size; if (m &gt; n) &#123; // to ensure m&lt;=n int *temp = nums1; nums1 = nums2; nums2 = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; iMin = i + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iMax = i - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = nums1[i - 1] &gt; nums2[j - 1] ? nums1[i - 1] : nums2[j - 1]; &#125; if ((m + n) % 2 == 1) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = nums2[j] &gt; nums1[i] ? nums1[i] : nums2[j]; &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0;&#125; 耗时如图： 还是比较不错的。时间复杂度：O(log(min(m,n))).空间复杂度：O(1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3(Longest Substring)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode3%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating Characters题目描述 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3. 简述：统计字符串不重复字符最长子串的长度。 C语言实现 使用两个下标i，index。i作为字符串的下标，依次往下移动。index为子串的下标往右移动。index+i是在母串移动的位置。初始化子串p比母串大1，不然有的编译器报越界。每次赋值后给下一位赋值&#39;\0&#39;，1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;string.h&gt;int isInclude(char *s, char a) &#123; while (*s != '\0') &#123; if (*s == a) &#123; return 1; &#125; s++; &#125; return 0;&#125;void clear(char *s) &#123; while (*s != '\0') &#123; *s = '\0'; s++; &#125;&#125;int lengthOfLongestSubstring(char *s) &#123; int i = 0, max = 0; int index = 0; char p[strlen(s) &gt; 0 ? strlen(s)+1 : 1]; while (s[i] != '\0') &#123; if (!isInclude(p, s[i + index])) &#123; p[index] = s[i + index]; p[index+1] = '\0'; index++; if (index &gt;= max) &#123; max = index; &#125; if (s[index + i] == '\0') &#123; break; &#125; &#125; else &#123; index = 0; clear(p); i++; &#125; &#125; return max;&#125;int main() &#123; char *s = "vfqsrebtogjmcanajfyzvypzibtngtrca"; int length = lengthOfLongestSubstring(s); printf("LongestLength=%d\n", length); return 0;&#125; 因为C语言没有现成使用的集合类，如（Map,Set），书写起来较为复杂。算法复杂度也挺高。下图为执行耗时，比较不理想。 时间复杂度： 遍历母串加子串移动n(n-1) ，找到一个字符需要从头查找比对。最坏情况为，n(n-1)*n ，时间复杂度O(n^3) 空间复杂度：O(n)+1 Java实现（使用Set实现） 通过集合Set的特性集合中不能出现重复值，检测子串在Set中是否存在，存在的话把集合里面连同本身及之前的元素全部去掉。这种方式被称为SLIDING WINDOW(滑动窗口) 123456789101112131415161718//最初实现 public int lengthOfLongestSubstring_2(String s) &#123; int max = 0; int i = 0, j = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while (i &lt; s.length() &amp;&amp; j &lt; s.length()) &#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); max = Math.max(max, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return max; &#125; 执行流程如下：String s = &quot;abcaea&quot; i set j max j - i 0 a 1 1 1 0 a,b 2 2 2 0 a,b,c 3 3 3 1 b,c 3 3 2 1 b,c,a 4 4 3 1 b,c,a,e 5 4 4 2 c,a,e 5 4 3 3 a,e 5 4 2 4 e 5 4 1 4 ea 6 4 2 算法复杂度 O(2n) =O(n)空间复杂度 O(n) Java实现(HashMap 优化) 使用HashMap自动覆盖重复的key相同的value，记录下每个字符在字符串中出现的最后位置。使用i记录不重复字符子串的起点，j-i-1表示字符串的长度。出现重复字符是更新i的位置。 1234567891011121314151617//HashMap public int lengthOfLongestSubstring_3(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for (int i = 0,j=0; j &lt; s.length(); j++) &#123; if (map.containsKey(s.charAt(j)))&#123; i = Math.max(map.get(s.charAt(j)),i); &#125; max = Math.max(max, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return max; &#125; 时间复杂度：O(n)空间复杂度：O(n)效率比HashSet快的原因是，没有对字符移除的操作，并且HashMap的查询速率把HashSet更快。 Java实现 (使用ASCII 128） 标准ASCll表示从0-127表示128个字符，通过字符代表ASCll值字符位置，数组中存储的是每个字符在字符串中出现的最后位置。是对HashMap实现的优化。因为没有了查询耗时，这种的执行效率最好。 12345678910111213141516public int lengthOfLongestSubstring_4(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125; 时间复杂度：O(n)空间复杂度：O(n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2(Add Two Numbers)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode2%2F</url>
    <content type="text"><![CDATA[Add Two Numbers题目描述 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 简单描述：两个链表按顺序相加，大于10的取10的余数(%10),向下位进1。 ######注意点：当最后一个节点的和大于等于10时，需要增加一个节点。 C语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;struct ListNode&#123; int val; struct ListNode *next; &#125;; //创建NULL节点 struct ListNode* newNode(int a)&#123; struct ListNode* newListNode = malloc(sizeof(struct ListNode)); if(newListNode==NULL)&#123; return NULL; &#125; newListNode-&gt;val = a; newListNode-&gt;next = NULL; return newListNode; &#125;//创建 指定长度和数据的链表 struct ListNode* createListNode(long array[],int n)&#123; int i; struct ListNode *head,*p; head = p = newNode(array[0]); for(i=1;i&lt;n;i++)&#123; p-&gt;next = newNode(array[i]); p = p-&gt;next; &#125; return head;&#125;struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode * p1,*p2; p1 = l1; p2 = l2; struct ListNode* head; head = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* p3 = head; int t =0; while(p1!=NULL || p2!=NULL)&#123; int a1 = p1!=NULL? p1-&gt;val : 0; int a2 = p2!=NULL? p2-&gt;val : 0; int sum = a1+a2+t; t = sum/10; p3-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); p3 = p3-&gt;next; p3-&gt;val = sum%10; if(p1!=NULL)&#123; p1 = p1-&gt;next; &#125; if(p2!=NULL)&#123; p2 = p2-&gt;next; &#125; &#125; if(t&gt;0)&#123; p3-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); p3 = p3-&gt;next; p3-&gt;val = t; &#125; p3-&gt;next=NULL; return head-&gt;next;&#125;//测试int main()&#123; struct ListNode *l1,*l2;// int a1[] = &#123;2,4,3&#125;;// int a2[] = &#123;5,6,4&#125;;// l1 = createListNode(a1,3);// l2 = createListNode(a2,3);// long a1[] = &#123;9&#125;;// long a2[] = &#123;1,9,9,9,9,9,9,9,9,9&#125;;// l1 = createListNode(a1,1);// l2 = createListNode(a2,10); long a1[] = &#123;5&#125;; long a2[] = &#123;5&#125;; l1 = createListNode(a1,1); l2 = createListNode(a2,1); struct ListNode *p = addTwoNumbers(l1,l2); while(p!=NULL)&#123; printf("-&gt;%d",p-&gt;val); p = p-&gt;next; &#125; return 0;&#125; 复杂度分析： 时间复杂度：O(max(m,n))， 只有一个while语句，传入的2个链表的最大长度决定循环的次数。 空间复杂度：O(max(m,n))，传入的2个链表的最大空间决定新建链表的最大空间，如果最后节点和大于等于10，空间复杂度为O(max(m,n))+1。 Java实现 123456789101112131415161718192021222324252627public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head= new ListNode(0); ListNode p = l1, q = l2, curr = head; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return head.next;&#125; Java版和C语言版基本一样。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1(Two Sum)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode1%2F</url>
    <content type="text"><![CDATA[Two Sum题目描述 (md partial supported) Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. C语言实现 通过最简单的方式，两个下标，先保持一个下标i不动，另一个下标j从第一个下标后一个开始移动，j移动到最后一个后，开始移动第一个下标i。12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;//时间复杂度 O(n^2) int* twoSum(int* nums, int numsSize, int target) &#123; int i,j; int * indices = (int*)malloc(2*sizeof(int)); for(i=0;i&lt;numsSize;i++)&#123; for(j=i+1;j&lt;numsSize;j++)&#123; if(nums[i]+nums[j] == target)&#123; *indices = i; *(indices+1)= j; break; &#125; &#125; &#125; return indices;&#125;//测试代码int main()&#123; int i; int a[5] = &#123;2,7,11,15&#125;; int *p = twoSum(a,5,9); for(i=0;i&lt;2;i++)&#123; printf("%d ",*(p+i)); &#125; return 0; &#125; Java实现(优化过) 使用Map集合，Map里存储目标值与数组值之差target-num[i] 和 下标 i，然后判断num[i]是否在Map的key中，不在时继续存储，在时就是所找目标值。这种方式时间复杂度为O(n)，执行效率大大提高。123456789101112131415161718192021public class One &#123; public static void main(String[] args) &#123; One one = new One(); int[] array = one.twoSum(new int[]&#123;2, 7, 11, 15&#125;,10); System.out.println(Arrays.toString(array)); &#125; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(!map.containsKey(nums[i]))&#123; map.put(target-nums[i],i); &#125;else &#123; return new int[]&#123;i,map.get(nums[i])&#125;; &#125; &#125; throw new RuntimeException("no exist"); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[漫谈数据结构——1、概述]]></title>
    <url>%2F2019%2F01%2F16%2FdataStructure1%2F</url>
    <content type="text"><![CDATA[1、为什么要学习数据结构？&emsp; &emsp;数据结构是是计算机专业最重要的基础之一，它是大学计算机专业的必修课，也是程序员提高自己的重要知识结构。对于学生而言，它对你以后考研和面试都用很重要的帮助。对于程序员而言，它能拓宽人的学习深度，决定了你日后能到达怎样的高度，更能体现人的学习素养，对日后的工作面试有很大的用途。 &emsp; &emsp;本教程主要介绍数据结构的常见用法，为了兼容更多人群，所有以C语言为主要的编程语言。如果您C语言基础不过关，请自行Google。其次，语言只是描述程序的一种形式，万变不离其中，掌握一种也就很容易掌握另外一种。 2、什么是数据结构？维基百科给出了定义: 数据结构（英语：data structure）是计算机中存储、组织数据的方式。无论是大数据时代的海量数据的存储，还是简单用户信息或者学生信息的存储，其数据存储的底层都要以某种更方便、更快捷且更省内存空间的方式进行，这种存储方式就是数据结构。如下图，就是一个简单的数据结构，他描述一个基础的学生信息，由id,name,sex,class组成。 id name sex class 001 张三 男 1班 002 李四 男 2班 003 王五 男 3班 2.1、基本术语 数据 &emsp; &emsp;计算机中存储的的最小单位 数据元素 &emsp; &emsp; 也叫元素或记录，及为上表中的一行。 数据对象 &emsp; &emsp; 数据元素的集合 3、数据结构的分类3.1、逻辑结构 描述元素之间的逻辑关系，与数据的存储位置无关。他包括集合、线性结构，树形结构和图形结构。 1、集合&emsp; &emsp; 类似于数学中的集合，一个数据存在于集合中，数据之间没有什么关系。 2、线性结构&emsp; &emsp; 与元素具有一对一的关系，在内存中逐个排列。它分为顺序存储和链式存储，顺序存储相当于高级语言的数组，在内存中排列是连续的。链式存储使用链表维护元素，在内存中排列是不连续的。 3、树形结构&emsp; &emsp; 使用树来维护元素的多个层次关系（对二叉树不了解请点击链接），除根结点外，一个节点只有一个父结点，可以根据一个节点寻找它的子结点或者父结点。 4、图形结构&emsp;&emsp;使用图)来维护元素的多个层次关系（图不了解请点击链接），一个图中的结点可以有多个父结点和子结点。 3.2、存储结构1、顺序存储结构&emsp;&emsp;使用顺序表来存储数据，数据存储在是连续的内存单元上。 优点：查询效率高，可以使用元素的下标直接找到某一个元素。因为其存储结构是紧密的，所以提高了空间利用率。 缺点：插入和删除一个元素的效率低，插入或者删除一个元素，要把这个元素的右边所有元素右移或者左移1个单位，随着数据量的增大，插入和删除的效率也会随之下降。且存储空间大小在定义时已经明确指定，操作元素是会出现“溢出”或者浪费空间的情况。 2、链式存储结构&emsp;&emsp;使用链表来存储数据，数据存储在是不连续的内存单元上。 优点：插入和删除效率很高，不会造成空间的浪费。 缺点：无法随机访问，内存单元一部分用来存储元素之间的逻辑关系，造成空间利用率低。 3、索引存储结构&emsp;&emsp;除建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引表由若干索引项组成 &emsp;&emsp;特点：索引存储结构是用结点的索引号来确定结点存储地址，其优点是检索速度快，缺点是增加了附加的索引表,会占用较多的存储空间。 4、散列存储结构&emsp;&emsp;散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。 &emsp;&emsp;散列法存储的基本思想是：由节点的关键码值决定节点的存储地址。散列技术除了可以用于查找外，还可以用于存储。 &emsp;&emsp;特点：散列是数组存储方式的一种发展，相比数组，散列的数据访问速度要高于数组，因为可以依据存储数据的部分内容找到数据在数组中的存储位置，进而能够快速实现数据的访问，理想的散列访问速度是非常迅速的。 4、算法程序 = 数据结构 + 算法 算法是数据结构的灵魂，一个数据结构设计的再好，如果没有算法，如同失去了灵魂，它的存在就毫无意义。 4.1 什么是算法&emsp;&emsp;算法是解决某个特定问题的具体步骤。 &emsp;&emsp;描述算法的方法：伪代码法，N-S结构化流程图和流程图， 具体方法请自行百度。 4.2 算法的特性 确定性 可行性 有穷性 零个或者多个输入 一个或者多个输出 正确性 可读性 健壮性 高效率和低存储 4.3 算法的复杂度&emsp;&emsp;用来表示算法执行消耗的计算机资源，主要从时间和空间两个方面考虑。 1、时间复杂度&emsp;&emsp;描述算法的执行时间(次数)，常用O(n)表示。推导方法: n为常数，用1代替。 n为未知数，系数为1，只保留最高阶项。 n为未知数，系数不为1，只保留最高阶项且最高阶项除去系数。 例子如下：123int a = 1;int b = 2;int sum = a + b; 共执行$f（n）= 3$ 次，所以 时间复杂度为O(1)。 1234567void fun()&#123; int i,sum; //执行一次 for(i=0;i&lt;n;i++)&#123; sum += i; //执行n次 &#125; printf("%d\n",sum); //执行一次&#125; 共执行$f（n）= n+3 $次，所以 时间复杂度为O(n)。 123456void fun()&#123; int i = 1; while(i &lt; n)&#123; i * = 2; &#125;&#125; 共执行$ 2^f = n $, 即 $ f = {log_2{n}}$，所以复杂度为O(logn)。 2、空间复杂度&emsp;&emsp;算法运行所占空间的大小，常用O(n)表示。 4、算法和数据结构&emsp;&emsp;算法通常是决定程序效率的关键，但是一切算法最终都要在相应的数据结构上实现，许多算法的精髓就是在于选择了合适的数据结构作为基础。在程序设计中，不但要注重算法设计，也要正确选择数据结构，这样往往能够事半功倍。 具体参考如下:LeetCode1 使用散列存储，极大的提高了算法效率。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 6(ZigZag Conversion)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode6%2F</url>
    <content type="text"><![CDATA[ZigZag Conversion（ZigZag转换）1、题目描述：The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)P &emsp;&emsp; &emsp;A &emsp;&emsp;&emsp;H &emsp; &emsp; &emsp;NA &emsp;P &emsp; L&emsp; S&emsp; I&emsp; &emsp;I &emsp; GY &emsp;&emsp;&emsp; I &emsp;&emsp;&emsp; RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows);Example 1: Input: s = “PAYPALISHIRING”, numRows = 3Output: “PAHNAPLSIIGYIR” &emsp; &emsp;给出一个指定字符串和numRows，把字符串按倒Z的形式排列，行数为numRows，按行排列返回字符串。 2、解决方法1：按行分类(Java实现)&emsp; &emsp;仔细观察这个Z型的图形，它是由nomRows行子串构成。所以可以遍历整个字符串把字符依次添加到指定行字符串上，方向为先下后上。 123456789101112131415161718192021222324252627282930313233343536373839public String convert(String s, int numRows) &#123; //numRows为1，直接返回s if (numRows==1)&#123; return s; &#125; //构建Math.min(numRows, s.length())个字符串(字符串的长度小于numRows，集合长度取s.length)， // 放在集合中。也可以使用字符串数组实现。 //使用StringBuilder可以使字符串拼接更快。 List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) &#123; StringBuilder stringBuilder = new StringBuilder(); rows.add(stringBuilder); &#125; int curRow = 0; //当前行 boolean dir = false; //当前方向 true向下 false向上 for (char c : s.toCharArray()) &#123; rows.get(curRow).append(c); //第一行或最后一行时，换方向 if (curRow ==0 || curRow ==numRows -1 )&#123; dir = ! dir; &#125; //换行 curRow += dir ? 1 : -1; &#125; //拼接字符串集合 StringBuilder str = new StringBuilder(); for (StringBuilder sb : rows) &#123; str.append(sb); &#125; return str.toString(); &#125; 运行耗时：53ms 时间复杂度：O(n) 遍历字符串的长度为len(s)。空间复杂度：O(n) 存储了len(s)的字符。 解决方法2：按行访问(C语言实现)原理：找到每一行中的字符在字符串中的出现位置。 如图： &emsp; &emsp;仔细观察第一行中P和A中间距中间相隔3个子串，实际下标相差4。在图上看的话其实是相差一列加一条对角线，所以第一行的字符位置可以表示为k*(2 * numRows - 2) ，k为字符在一行字符串中所处的位置。最后一行的字符位置可以用第一行加numRows-1表示，所以可以表示为k*(2 * numRows - 2) - numRows -1。中间的字符包含两个部分，分别是 k*(numRows -2) + i 和 （k+1)*(numRows -2) - i。1234567891011121314151617181920212223242526char *convert_2(char *s, int numRows) &#123; if (numRows == 1) &#123; return s; &#125; int length = strlen(s); int cycleLen = 2 * numRows - 2; //长度比原字符串多1，有个'\0' char *ret = (char *) malloc(sizeof(char) * (length + 1)); int index = 0; for (int i = 0; i &lt; numRows; ++i) &#123; for (int j = 0; j + i &lt; length; j += cycleLen) &#123; //第一行、最后一行和中间行的列部分 ret[index++] = s[j + i]; //中间行字符串的对角线部分 if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; j + cycleLen - i &lt; length) &#123; ret[index++] = s[j + cycleLen - i]; &#125; &#125; &#125; ret[index] = '\0'; return ret;&#125; 运行耗时：12ms时间复杂度：O(n) 把所有字符的下标遍历了一遍。空间复杂度：O(n) 分配指针len(s)+1个空间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5(Longest Palindromic Substring)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode5%2F</url>
    <content type="text"><![CDATA[Longest Palindromic Substring（最大回文字符串）1、题目描述：Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer.Example 2: Input: “cbbd”Output: “bb” 给出一个字符串s，找出长度最大的回文子串，s的最大长度小于1000。 2、摘要：下面介绍了几种方法实现：回文，动态规划和字符串操作。回文的定义：一个字符串从两个方向读，它的内容是相同的。例如：S = “aba”是回文字符串，而S = “abc”不是回文字符串。 3、解决方法：方法1：Brute Force(暴力破解)很明显，暴力破解就是找到所有子串验证它是否是回文字符串。 Java实现：12345678910111213141516171819202122232425public boolean isPalindrome(String s) &#123; String ss = new StringBuilder(s).reverse().toString(); if (ss.equals(s)) &#123; return true; &#125; return false; &#125;public String longestPalindrome(String s) &#123; int longestLength = 0; String longestSubString = ""; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i+1; j &lt;= s.length(); j++) &#123; String subString = s.substring(i,j); if (isPalindrome(subString) &amp;&amp; subString.length()&gt;longestLength)&#123; longestLength = subString.length(); longestSubString = subString; &#125; &#125; &#125; return longestSubString; &#125; 时间复杂度：&emsp;&emsp;两个for循环中嵌套了一个判断回文的过程，回文判断我使用的是StringBuilder的reverse()方法，时间复杂度一共是O(n^3)。比较不理想，提交上去会出现时间超时。 空间复杂度：两个变量，复杂度为O(1)。 ######方法2：Longest Common Substring(最长的公共子串)&emsp;&emsp;一些人可能会想出一个最快的方法，倒序字符串s，然后与原字符串对比，然后找出最长的公共子串，这个子串一定就是最长的回文子串。&emsp;&emsp;从表面上看这个方法是正确的，但是仔细想来并不是完全正确，例如S = “abacdfgdcaba”,他和倒序的公共最长字符为 “abacd”，然而这个并不是回文字符串。导致出现这个情况的原因是原字符串中存在一个非回文倒序副本。如果要排除这个影响，就要在候选字符串中 检查子串的索引是否与反向子串的原始索引相同，相同就保留，不同就舍弃。 &emsp;&emsp;首先实现寻找最长的公共子串，具体步骤参考：https://blog.csdn.net/u010397369/article/details/38979077&emsp;&emsp;具体实现思路就是把两个字符串组成一个二维数组 ，如果两个对应字符相等，就执行 temp[ i ][ j ] = temp[ i - 1 ][ j - 1] + 1。因为i-1或者j-1会越界，所以可以单独处理。temp[ i ][ j ] 保存的就是公共子串的长度。 Java实现123456789101112131415161718192021222324252627282930public String longestPalindrome_2(String s) &#123; if (s.equals("")) &#123; return ""; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[][] temp = new int[s.length()][ss.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); //原字符串做列,倒序后的子串作为行 for (int i = 0; i &lt; ss_char.length; i++) &#123; for (int j = 0; j &lt; s_char.length; j++) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[i][j] = 1; &#125; else &#123; temp[i][j] = temp[i - 1][j - 1] + 1; &#125; &#125; if (temp[i][j] &gt; longestlength) &#123; longestlength = temp[i][j]; maxEnd = i; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1); &#125; &emsp;&emsp;以上算法只能实现寻找最长的公共子串，如果s=”abc435cba”，公共子串为”abc”，但是这个不是回文字符串。为了解决这个问题，我们还要对比子串在倒序后的字符串的位置和原字符串的位置是否对应。&emsp;&emsp;举个例子，如果s=”caba”,s’ = “abac”，他们的最长回文串为“aba”,“aba”在原字符串中的位置为 1 2 3 ，在s’中的位置为 0 1 2，所以 aba 就是我们需要找的。当然我们不需要每个字符都判断，我们只需要判断末尾字符就可以。如图：&emsp;&emsp;i所指的字符a在原字符串中的位置为beforeRev = length - i- 1 = 0，beforeRev就是在j中为第一个字符位置，且 beforeRev + temp[i][j] - 1 =2代表j中最后一个字符的位置，如果位置与j相等，aba就是要找的。我们可以写出如下代码：12345678910111213141516171819202122232425262728293031323334//动态规划 (获取最长回文串) 需要和原字符对比位置 public String longestPalindrome_3(String s) &#123; if (s.length() &lt;= 1) &#123; return s; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[][] temp = new int[s.length()][ss.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); //原字符串做列,倒序后的子串作为行 for (int i = 0; i &lt; ss_char.length; i++) &#123; for (int j = 0; j &lt; s_char.length; j++) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[i][j] = 1; &#125; else &#123; temp[i][j] = temp[i - 1][j - 1] + 1; &#125; &#125; if (temp[i][j] &gt; longestlength) &#123; /*******************增加的部分***********************/ int beforeRev = s.length() - i - 1; if (beforeRev + temp[i][j] - 1 == j) &#123; longestlength = temp[i][j]; maxEnd = i; &#125; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1); &#125; 执行时间： 时间复杂度：两个嵌套循环，O(n^2)空间复杂度：一个二维数组，O(n^2) &emsp;&emsp;仔细观察可以发现，我们判断字符相等的只用到了temp[i][j]，一行用过之后就弃置不用了。所以我们可以把空间复杂度优化到O(n)，只需要把一个一维数组重新赋值即可，因为正序赋值有可能覆盖改后面需要使用的数据比如a[3] = a[2]+1时，计算a[4]的时候a[3]的值就不是原来的了。所以我们需要从后往前计算，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public String longestPalindrome_4(String s) &#123; if (s.equals("")) &#123; return ""; &#125; String ss = new StringBuilder(s).reverse().toString(); //倒序 int longestlength = 0; int maxEnd = 0; int[] temp = new int[s.length()]; char[] s_char = s.toCharArray(); char[] ss_char = ss.toCharArray(); for (int i = 0; i &lt; s_char.length; i++) &#123; //初始化第一行 temp[i] = (s_char[0] == ss_char[i]) ? 1 : 0; &#125; for (int i = 0; i &lt; s_char.length; i++) &#123; for (int j = ss.length() - 1; j &gt;= 0; j--) &#123; if (s_char[i] == ss_char[j]) &#123; if (i == 0 || j == 0) &#123; temp[j] = 1; &#125; else &#123; temp[j] = temp[j - 1] + 1; &#125; if (temp[j] &gt; longestlength) &#123; /*******************增加的部分***********************/ int beforeRev = s.length() - j - 1; if (beforeRev + temp[j] - 1 == i) &#123; longestlength = temp[j]; maxEnd = i; &#125; &#125; &#125; else &#123; temp[j] = 0; &#125; &#125; &#125; return s.substring(maxEnd - longestlength + 1, maxEnd + 1);&#125; 运行时间： 时间复杂度：两个嵌套循环，O(n^2)空间复杂度：一个一维数组，O(n) 方法3：扩展中心&emsp;&emsp;我们观察到一个回文串是从一个中心到两边的镜像。所以，回文串可以从一个字符(奇数)或两个字符(偶数)的为中心拓展，它的中心总共有2n-1个。以i为中心左边为left，右边为right，先令left=right=i，满足left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)时，left–;right++;向外拓展，直到结束。回文的长度就是right - left - 1。实现如下:Java实现：1234567891011121314151617181920212223242526//方法 扩展中心public int expandAroundCenter(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; left--; right++; &#125; return right - left - 1;&#125;public String longestPalindrome_6(String s) &#123; if (s == null || s.length() &lt; 1) return ""; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); //奇数 int len2 = expandAroundCenter(s, i, i + 1);//偶数 int len = Math.max(len1, len2); if (len &gt; end - start) &#123; //重新计算start 和end start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1);&#125; 运行时间如下：&emsp;&emsp;因为只识别回文序列，过滤掉了很大部分情况，虽然时间复杂度为o(n^2)，但是执行效率更高。时间复杂度：两个嵌套循环，最坏的情况下，O(n^2)空间复杂度：O(1) 参考：https://leetcode.com/problems/longest-palindromic-substring/solution/[](https://leetcode.com/problems/longest-palindromic-substring/solution/)http://windliang.cc/2018/08/05/leetCode-5-Longest-Palindromic-Substring/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4(Median of Two Sorted Arrays)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode4%2F</url>
    <content type="text"><![CDATA[Median of Two Sorted Arrays题目:There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. 描述：两个已经排序好的数组，数组不是空，求中位数。要求算法的时间复杂度是O(long(m+n))。 分析:1、如果不看时间复杂度的话，可以使用暴力方法实现：把两个数组拼接，然后重新排序，寻找中位数，较为简单，使用Java实现。2、要是考虑复杂度的话，较为困难，后面会用C语言具体分析。 1、Java实现内容简单，这里不做解释。123456789101112131415public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; double median = 0.0f; int m = nums1.length; int n = nums2.length; int[] newNums = Arrays.copyOf(nums1, nums1.length + nums2.length); System.arraycopy(nums2, 0, newNums, nums1.length, nums2.length); Arrays.sort(newNums); if ((m + n) % 2 == 0) &#123; median = (newNums[(m + n) / 2] + newNums[(m + n) / 2 - 1]) / 2.0; &#125; else &#123; median = newNums[(m + n) / 2]; &#125; return median; &#125; 运行时间： 时间复杂度：主要是Arrays.sort()使用的快排，时间复杂度为O( (n+m)*log(n+m) ) 空间复杂度：O(n+m) 2、 C语言实现(1)新建一个长度为 (m+n)/2 +1 的数组newnums，i,j为先指向数组nums1 和mums2的第0个元素,通过i,j的移动把两个源数组的按照升序复制到新数组newnums中。 1. 处理源数组是空的情况，一个如果是空，另一个直接复制数组到newnums中。 2. 两个都不为空，开始循环，循环次数为length/2+1(总长度一半+1) 3. 控制移动边界i&gt;=num1Size时，nums1到最后一个元素，从nums2赋值，j&gt;=num2Size时，nums2到最后一个元素，从nums1赋值。判断nums1[i] &lt; nums2[j],每次都把较小的元素赋值到新数组中。 4.分偶数和奇数判断中位数情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123; int length = nums1Size + nums2Size; int *newnums = (int *) malloc(sizeof(int) * (length / 2 + 1)); int index = 0, i = 0, j = 0; double median; if (nums1Size == 0) &#123; newnums = nums2; &#125; else if (nums2Size == 0) &#123; newnums = nums1; &#125; else &#123; while (index &lt;= length / 2) &#123; if (i &gt;= nums1Size) &#123; newnums[index] = nums2[j]; j++; &#125; else if (j &gt;= nums2Size) &#123; newnums[index] = nums1[i]; i++; &#125; else &#123; if (nums1[i] &lt; nums2[j]) &#123; newnums[index] = nums1[i]; i++; &#125; else &#123; newnums[index] = nums2[j]; j++; &#125; &#125; index++; &#125; &#125; if (length % 2 == 0) &#123; median = (newnums[length / 2 - 1] + newnums[length / 2]) / 2.0; &#125; else &#123; median = newnums[length / 2]; &#125; return median;&#125; 运行时间： 时间复杂度：O((n+m)/2+1) = O(n) 空间复杂度：O((n+m)/2+1) = O(n) 3、C语言实现(2)中位数的定义是把一个集合分为左右长度相等的两个子集合，所以我们如果保证两个数组的，左半部分的长度=右半边分长度，就可以找出中位数。这时候要保证: len(left_part) = len(right_part)max(left_part) &lt;=min(right_part) 令 len(left_part) = i len(right_part)) = ji = m - i j = n - j 因此我们需要确保 i + j = m - i +n - j (or i + j = m - i + n - j + 1)if m&lt;=n 我们需要设置 i ~(0,m) ， j = (m + n + 1)/2 - i nums2[j−1]≤nums1[i] 和 nums1[i−1]≤nums2[j] 我们需要先确保m&lt;=n，如果m&gt;n时，j可能会小于 0，然后使用二分法查询数组，处理好四种边界问 题i = 0 ，j = 0 ，i = m 或 j = n的情况，具体细节看代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) &#123; int m = nums1Size; int n = nums2Size; if (m &gt; n) &#123; // to ensure m&lt;=n int *temp = nums1; nums1 = nums2; nums2 = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; nums2[j - 1] &gt; nums1[i]) &#123; iMin = i + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; nums1[i - 1] &gt; nums2[j]) &#123; iMax = i - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = nums1[i - 1] &gt; nums2[j - 1] ? nums1[i - 1] : nums2[j - 1]; &#125; if ((m + n) % 2 == 1) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = nums2[j] &gt; nums1[i] ? nums1[i] : nums2[j]; &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0;&#125; 耗时如图： 还是比较不错的。时间复杂度：O(log(min(m,n))).空间复杂度：O(1)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3(Longest Substring)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode3%2F</url>
    <content type="text"><![CDATA[Longest Substring Without Repeating Characters题目描述 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3. 简述：统计字符串不重复字符最长子串的长度。 C语言实现 使用两个下标i，index。i作为字符串的下标，依次往下移动。index为子串的下标往右移动。index+i是在母串移动的位置。初始化子串p比母串大1，不然有的编译器报越界。每次赋值后给下一位赋值&#39;\0&#39;，1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;string.h&gt;int isInclude(char *s, char a) &#123; while (*s != '\0') &#123; if (*s == a) &#123; return 1; &#125; s++; &#125; return 0;&#125;void clear(char *s) &#123; while (*s != '\0') &#123; *s = '\0'; s++; &#125;&#125;int lengthOfLongestSubstring(char *s) &#123; int i = 0, max = 0; int index = 0; char p[strlen(s) &gt; 0 ? strlen(s)+1 : 1]; while (s[i] != '\0') &#123; if (!isInclude(p, s[i + index])) &#123; p[index] = s[i + index]; p[index+1] = '\0'; index++; if (index &gt;= max) &#123; max = index; &#125; if (s[index + i] == '\0') &#123; break; &#125; &#125; else &#123; index = 0; clear(p); i++; &#125; &#125; return max;&#125;int main() &#123; char *s = "vfqsrebtogjmcanajfyzvypzibtngtrca"; int length = lengthOfLongestSubstring(s); printf("LongestLength=%d\n", length); return 0;&#125; 因为C语言没有现成使用的集合类，如（Map,Set），书写起来较为复杂。算法复杂度也挺高。下图为执行耗时，比较不理想。 时间复杂度： 遍历母串加子串移动n(n-1) ，找到一个字符需要从头查找比对。最坏情况为，n(n-1)*n ，时间复杂度O(n^3) 空间复杂度：O(n)+1 Java实现（使用Set实现） 通过集合Set的特性集合中不能出现重复值，检测子串在Set中是否存在，存在的话把集合里面连同本身及之前的元素全部去掉。这种方式被称为SLIDING WINDOW(滑动窗口) 123456789101112131415161718//最初实现 public int lengthOfLongestSubstring_2(String s) &#123; int max = 0; int i = 0, j = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while (i &lt; s.length() &amp;&amp; j &lt; s.length()) &#123; if (!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); max = Math.max(max, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return max; &#125; 执行流程如下：String s = &quot;abcaea&quot; i set j max j - i 0 a 1 1 1 0 a,b 2 2 2 0 a,b,c 3 3 3 1 b,c 3 3 2 1 b,c,a 4 4 3 1 b,c,a,e 5 4 4 2 c,a,e 5 4 3 3 a,e 5 4 2 4 e 5 4 1 4 ea 6 4 2 算法复杂度 O(2n) =O(n)空间复杂度 O(n) Java实现(HashMap 优化) 使用HashMap自动覆盖重复的key相同的value，记录下每个字符在字符串中出现的最后位置。使用i记录不重复字符子串的起点，j-i-1表示字符串的长度。出现重复字符是更新i的位置。 1234567891011121314151617//HashMap public int lengthOfLongestSubstring_3(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for (int i = 0,j=0; j &lt; s.length(); j++) &#123; if (map.containsKey(s.charAt(j)))&#123; i = Math.max(map.get(s.charAt(j)),i); &#125; max = Math.max(max, j - i + 1); map.put(s.charAt(j), j + 1); &#125; return max; &#125; 时间复杂度：O(n)空间复杂度：O(n)效率比HashSet快的原因是，没有对字符移除的操作，并且HashMap的查询速率把HashSet更快。 Java实现 (使用ASCII 128） 标准ASCll表示从0-127表示128个字符，通过字符代表ASCll值字符位置，数组中存储的是每个字符在字符串中出现的最后位置。是对HashMap实现的优化。因为没有了查询耗时，这种的执行效率最好。 12345678910111213141516public int lengthOfLongestSubstring_4(String s) &#123; int n = s.length(), ans = 0; int[] index = new int[128]; // current index of character // try to extend the range [i, j] for (int j = 0, i = 0; j &lt; n; j++) &#123; i = Math.max(index[s.charAt(j)], i); ans = Math.max(ans, j - i + 1); index[s.charAt(j)] = j + 1; &#125; return ans; &#125; 时间复杂度：O(n)空间复杂度：O(n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 2(Add Two Numbers)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode2%2F</url>
    <content type="text"><![CDATA[Add Two Numbers题目描述 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 简单描述：两个链表按顺序相加，大于10的取10的余数(%10),向下位进1。 ######注意点：当最后一个节点的和大于等于10时，需要增加一个节点。 C语言123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;struct ListNode&#123; int val; struct ListNode *next; &#125;; //创建NULL节点 struct ListNode* newNode(int a)&#123; struct ListNode* newListNode = malloc(sizeof(struct ListNode)); if(newListNode==NULL)&#123; return NULL; &#125; newListNode-&gt;val = a; newListNode-&gt;next = NULL; return newListNode; &#125;//创建 指定长度和数据的链表 struct ListNode* createListNode(long array[],int n)&#123; int i; struct ListNode *head,*p; head = p = newNode(array[0]); for(i=1;i&lt;n;i++)&#123; p-&gt;next = newNode(array[i]); p = p-&gt;next; &#125; return head;&#125;struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode * p1,*p2; p1 = l1; p2 = l2; struct ListNode* head; head = (struct ListNode*)malloc(sizeof(struct ListNode)); struct ListNode* p3 = head; int t =0; while(p1!=NULL || p2!=NULL)&#123; int a1 = p1!=NULL? p1-&gt;val : 0; int a2 = p2!=NULL? p2-&gt;val : 0; int sum = a1+a2+t; t = sum/10; p3-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); p3 = p3-&gt;next; p3-&gt;val = sum%10; if(p1!=NULL)&#123; p1 = p1-&gt;next; &#125; if(p2!=NULL)&#123; p2 = p2-&gt;next; &#125; &#125; if(t&gt;0)&#123; p3-&gt;next = (struct ListNode*)malloc(sizeof(struct ListNode)); p3 = p3-&gt;next; p3-&gt;val = t; &#125; p3-&gt;next=NULL; return head-&gt;next;&#125;//测试int main()&#123; struct ListNode *l1,*l2;// int a1[] = &#123;2,4,3&#125;;// int a2[] = &#123;5,6,4&#125;;// l1 = createListNode(a1,3);// l2 = createListNode(a2,3);// long a1[] = &#123;9&#125;;// long a2[] = &#123;1,9,9,9,9,9,9,9,9,9&#125;;// l1 = createListNode(a1,1);// l2 = createListNode(a2,10); long a1[] = &#123;5&#125;; long a2[] = &#123;5&#125;; l1 = createListNode(a1,1); l2 = createListNode(a2,1); struct ListNode *p = addTwoNumbers(l1,l2); while(p!=NULL)&#123; printf("-&gt;%d",p-&gt;val); p = p-&gt;next; &#125; return 0;&#125; 复杂度分析： 时间复杂度：O(max(m,n))， 只有一个while语句，传入的2个链表的最大长度决定循环的次数。 空间复杂度：O(max(m,n))，传入的2个链表的最大空间决定新建链表的最大空间，如果最后节点和大于等于10，空间复杂度为O(max(m,n))+1。 Java实现 123456789101112131415161718192021222324252627public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125;public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head= new ListNode(0); ListNode p = l1, q = l2, curr = head; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return head.next;&#125; Java版和C语言版基本一样。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1(Two Sum)]]></title>
    <url>%2F2018%2F12%2F16%2Fleetcode1%2F</url>
    <content type="text"><![CDATA[Two Sum题目描述 (md partial supported) Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. C语言实现 通过最简单的方式，两个下标，先保持一个下标i不动，另一个下标j从第一个下标后一个开始移动，j移动到最后一个后，开始移动第一个下标i。12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;//时间复杂度 O(n^2) int* twoSum(int* nums, int numsSize, int target) &#123; int i,j; int * indices = (int*)malloc(2*sizeof(int)); for(i=0;i&lt;numsSize;i++)&#123; for(j=i+1;j&lt;numsSize;j++)&#123; if(nums[i]+nums[j] == target)&#123; *indices = i; *(indices+1)= j; break; &#125; &#125; &#125; return indices;&#125;//测试代码int main()&#123; int i; int a[5] = &#123;2,7,11,15&#125;; int *p = twoSum(a,5,9); for(i=0;i&lt;2;i++)&#123; printf("%d ",*(p+i)); &#125; return 0; &#125; Java实现(优化过) 使用Map集合，Map里存储目标值与数组值之差target-num[i] 和 下标 i，然后判断num[i]是否在Map的key中，不在时继续存储，在时就是所找目标值。这种方式时间复杂度为O(n)，执行效率大大提高。123456789101112131415161718192021public class One &#123; public static void main(String[] args) &#123; One one = new One(); int[] array = one.twoSum(new int[]&#123;2, 7, 11, 15&#125;,10); System.out.println(Arrays.toString(array)); &#125; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(!map.containsKey(nums[i]))&#123; map.put(target-nums[i],i); &#125;else &#123; return new int[]&#123;i,map.get(nums[i])&#125;; &#125; &#125; throw new RuntimeException("no exist"); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
